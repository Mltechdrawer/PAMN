{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Programaci\u00f3n de Aplicaciones M\u00f3viles NativasBienvenido a PAMN","text":""},{"location":"#programacion-de-aplicaciones-moviles-nativas_1","title":"\ud83d\udcf1 Programaci\u00f3n de Aplicaciones M\u00f3viles Nativas","text":"<p>Programaci\u00f3n de Aplicaciones M\u00f3viles Nativas (PAMN) es una asignatura optativa de 4.\u00ba curso del Grado en Ingenier\u00eda Inform\u00e1tica. Su objetivo es capacitar al alumnado en el dise\u00f1o, desarrollo y despliegue de aplicaciones m\u00f3viles nativas para sistemas operativos actuales. Se abordan aspectos como accesibilidad, calidad del software y pr\u00e1cticas DevOps. Esta materia ampl\u00eda los conocimientos adquiridos previamente en programaci\u00f3n m\u00f3vil, y refuerza un perfil profesional muy demandado en el sector tecnol\u00f3gico actual.</p> <p> </p> <p> </p> <p> </p> <p>\u00a9 2025 Mar\u00eda Dolores Afonso Su\u00e1rez. Este material se distribuye bajo licencia Creative Commons Atribuci\u00f3n 4.0 Internacional (CC BY 4.0).</p>"},{"location":"contenidos/","title":"Contenidos","text":"<p>Programaci\u00f3n de Aplicaciones M\u00f3viles Nativas (PAMN) Los bloques est\u00e1n estructurados con una secuencia acad\u00e9mica temporal, pero sus contenidos est\u00e1n estrechamente interrelacionados. Esta integraci\u00f3n favorece un aprendizaje progresivo y coherente, orientado a la realizaci\u00f3n del trabajo final de la asignatura con una visi\u00f3n global y aplicada del desarrollo de apps m\u00f3viles.</p> <p>BLOQUE 1. Ingenier\u00eda de Desarrollo de Aplicaciones M\u00f3viles Nativas Aborda los fundamentos de la ingenier\u00eda de aplicaciones m\u00f3viles, incluyendo el ciclo de vida del desarrollo, principios de arquitectura, accesibilidad y dise\u00f1o de interfaces. Proporciona una base s\u00f3lida para crear aplicaciones centradas en el usuario, accesibles y alineadas con est\u00e1ndares de calidad y normativas actuales.</p> <p>BLOQUE 2. Desarrollo de Aplicaciones M\u00f3viles Nativas profundiza en tecnolog\u00edas clave del desarrollo m\u00f3vil, como sistemas operativos, lenguajes de programaci\u00f3n, frameworks y bases de datos. Tambi\u00e9n introduce principios de calidad del software y patrones de dise\u00f1o, esenciales para crear aplicaciones eficientes, escalables y mantenibles en un entorno de desarrollo profesional.</p> <p>BLOQUE 3. Programaci\u00f3n y Despliegue de Aplicaciones M\u00f3viles Nativas exploran aspectos avanzados de programaci\u00f3n m\u00f3vil como la integraci\u00f3n de sensores, el manejo de errores y el logging. Se trabaja adem\u00e1s el despliegue de aplicaciones y su integraci\u00f3n en el ciclo DevOps, preparando al estudiante para llevar apps m\u00f3viles desde el desarrollo hasta la producci\u00f3n.</p>"},{"location":"Bloque1_Ingenieria_Apps/accesibilidad_normativa/accesibilidad/accesibilidad/","title":"Accesibilidad en Aplicaciones Web y M\u00f3viles","text":"<p>La accesibilidad es un aspecto fundamental en el desarrollo de aplicaciones web y m\u00f3viles. No solo garantiza la inclusi\u00f3n de personas con diversidad funcional, sino que tambi\u00e9n mejora la usabilidad general de los sistemas y ampl\u00eda su alcance a un p\u00fablico m\u00e1s diverso. Dise\u00f1ar con criterios de accesibilidad implica cumplir con principios universales que faciliten la interacci\u00f3n para todos los usuarios.</p> <p></p>"},{"location":"Bloque1_Ingenieria_Apps/accesibilidad_normativa/accesibilidad/accesibilidad/#ben-shneiderman-y-las-ocho-reglas-de-oro","title":"Ben Shneiderman y las Ocho Reglas de Oro","text":"<p>Ben Shneiderman es un inform\u00e1tico estadounidense. Su investigaci\u00f3n principal est\u00e1 relacionada con la Interacci\u00f3n Persona-ordenador. Destaca por ser un pionero en el campo de la interacci\u00f3n persona\u2013ordenador (HCI). Su trabajo ha sido una referencia clave en el dise\u00f1o de interfaces centradas en el usuario. En colaboraci\u00f3n con Catherine Plaisant, desarroll\u00f3 un marco conceptual que ayuda a guiar la construcci\u00f3n de interfaces m\u00e1s usables y accesibles. Una de sus contribuciones m\u00e1s destacadas son las Ocho Reglas de Oro del Dise\u00f1o de Interfaces.</p>"},{"location":"Bloque1_Ingenieria_Apps/accesibilidad_normativa/accesibilidad/accesibilidad/#1-esforzarse-por-la-consistencia","title":"1. Esforzarse por la consistencia","text":"<p>Los elementos de la interfaz deben mantener un comportamiento uniforme en toda la aplicaci\u00f3n, facilitando el aprendizaje y reduciendo errores.</p>  Detalles <p>\u274c Una aplicaci\u00f3n de banca m\u00f3vil en la que el bot\u00f3n de \u201cAceptar\u201d aparece a veces en verde en la esquina inferior derecha y en otras pantallas en rojo en la parte superior. El usuario nunca sabe d\u00f3nde buscarlo ni qu\u00e9 significa el color</p> <p>\u2714 En Gmail, los botones de acci\u00f3n (Redactar, Enviar, Eliminar) mantienen siempre el mismo dise\u00f1o, color y posici\u00f3n, lo que facilita que los usuarios sepan d\u00f3nde encontrarlos sin pensar.</p>"},{"location":"Bloque1_Ingenieria_Apps/accesibilidad_normativa/accesibilidad/accesibilidad/#2-permitir-atajos-para-usuarios-frecuentes","title":"2. Permitir atajos para usuarios frecuentes","text":"<p>El sistema debe ofrecer caminos r\u00e1pidos para usuarios expertos (como atajos de teclado o gestos) sin sacrificar la facilidad de uso para principiantes.</p>  Detalles <p>\u274c Un editor de texto que solo permite copiar y pegar desde el men\u00fa desplegable, sin admitir atajos de teclado como Ctrl+C / Ctrl+V. Los usuarios avanzados pierden tiempo constantemente. </p> <p>\u2714 En Microsoft Word, adem\u00e1s de usar los men\u00fas, los usuarios avanzados pueden utilizar atajos de teclado como Ctrl+B para poner en negrita o Ctrl+Z para deshacer, acelerando mucho su trabajo.</p>"},{"location":"Bloque1_Ingenieria_Apps/accesibilidad_normativa/accesibilidad/accesibilidad/#3-ofrecer-retroalimentacion-informativa","title":"3. Ofrecer retroalimentaci\u00f3n informativa","text":"<p>Cada acci\u00f3n del usuario debe tener una respuesta clara e inmediata que confirme su ejecuci\u00f3n. </p>  Detalles <p>\u274c Un formulario online en el que, al pulsar \u201cEnviar\u201d, no aparece ning\u00fan mensaje ni indicador de carga. El usuario no sabe si el sistema est\u00e1 procesando los datos, si hubo un error o si ya se enviaron </p> <p>\u2714 En WhatsApp, cuando env\u00edas un mensaje aparece primero un check (enviado), luego dos checks (recibido) y m\u00e1s tarde en azul (le\u00eddo). El usuario sabe en todo momento qu\u00e9 ha pasado con su mensaje.</p>"},{"location":"Bloque1_Ingenieria_Apps/accesibilidad_normativa/accesibilidad/accesibilidad/#4-disenar-dialogos-que-produzcan-cierre","title":"4. Dise\u00f1ar di\u00e1logos que produzcan cierre","text":"<p>Las interacciones deben estructurarse con un inicio, un desarrollo y un fin reconocible, dando al usuario sensaci\u00f3n de control y finalizaci\u00f3n. </p>  Detalles <p>\u274c Un proceso de compra en l\u00ednea que finaliza con un bot\u00f3n \u201cContinuar\u201d pero nunca muestra una pantalla de confirmaci\u00f3n del pedido. El usuario queda con la duda de si la compra fue exitosa. </p> <p>\u2714 En Amazon, despu\u00e9s de finalizar la compra, aparece una p\u00e1gina de confirmaci\u00f3n con el n\u00famero de pedido y un correo electr\u00f3nico de resumen. El usuario queda seguro de que su acci\u00f3n termin\u00f3 con \u00e9xito.</p>"},{"location":"Bloque1_Ingenieria_Apps/accesibilidad_normativa/accesibilidad/accesibilidad/#5-ofrecer-prevencion-y-manejo-de-errores-simples","title":"5. Ofrecer prevenci\u00f3n y manejo de errores simples","text":"<p>El sistema debe minimizar la posibilidad de errores y, si ocurren, ofrecer mecanismos claros para resolverlos. </p>  Detalles <p>\u274c Un sistema que obliga a introducir la fecha de nacimiento en formato \u201cDD/MM/AAAA\u201d sin validaci\u00f3n, y al escribir \u201c1/1/24\u201d muestra un error gen\u00e9rico: \u201cFormato inv\u00e1lido\u201d, sin explicar qu\u00e9 est\u00e1 mal ni c\u00f3mo corregirlo. </p> <p>\u2714 En Google Forms, si intentas enviar un formulario sin rellenar un campo obligatorio, aparece un aviso rojo bajo ese campo explicando qu\u00e9 falta, y no permite continuar hasta solucionarlo.</p>"},{"location":"Bloque1_Ingenieria_Apps/accesibilidad_normativa/accesibilidad/accesibilidad/#6-permitir-deshacer-acciones","title":"6. Permitir deshacer acciones","text":"<p>Es fundamental que los usuarios tengan la posibilidad de corregir sus acciones mediante funciones de \u201cdeshacer\u201d o \u201ccancelar\u201d.</p>  Detalles <p>\u274c Una aplicaci\u00f3n de edici\u00f3n de im\u00e1genes que, al aplicar un filtro, reemplaza la foto original sin opci\u00f3n de \u201cdeshacer\u201d ni recuperar la versi\u00f3n previa. </p> <p>\u2714 En Gmail, al borrar un correo aparece durante unos segundos el bot\u00f3n \u201cDeshacer\u201d, que permite recuperar de inmediato el mensaje eliminado por error.</p>"},{"location":"Bloque1_Ingenieria_Apps/accesibilidad_normativa/accesibilidad/accesibilidad/#7-apoyar-el-control-interno-del-usuario","title":"7. Apoyar el control interno del usuario","text":"<p>El sistema debe dar la sensaci\u00f3n de que el usuario controla la interacci\u00f3n, evitando procesos autom\u00e1ticos inesperados.</p>  Detalles <p>\u274c Una web que autom\u00e1ticamente abre un v\u00eddeo a pantalla completa con sonido sin pedir permiso al usuario, interrumpiendo lo que estaba haciendo.  </p> <p>\u2714 En YouTube, si inicias un v\u00eddeo, siempre puedes pausarlo, saltar hacia adelante, ajustar el volumen o desactivar la reproducci\u00f3n autom\u00e1tica. El usuario decide c\u00f3mo y cu\u00e1ndo interactuar..</p>"},{"location":"Bloque1_Ingenieria_Apps/accesibilidad_normativa/accesibilidad/accesibilidad/#8-reducir-la-carga-de-memoria-a-corto-plazo","title":"8. Reducir la carga de memoria a corto plazo","text":"<p>La interfaz debe apoyarse en la memoria de reconocimiento antes que en la de recuerdo, utilizando men\u00fas, \u00edconos y ayudas visuales para reducir el esfuerzo cognitivo. </p>  Detalles <p>\u274c Un sistema de reservas que pide al usuario memorizar un c\u00f3digo de 12 d\u00edgitos mostrado en una pantalla, y luego escribirlo manualmente en la siguiente sin ofrecer copiar/pegar ni mostrarlo de nuevo.  </p> <p>\u2714 En los navegadores web, al introducir un nombre de usuario, aparece la lista de autocompletado con los datos previamente guardados. As\u00ed el usuario no necesita memorizar ni volver a escribirlos cada vez.</p> <p>Las Ocho Reglas de Oro de Ben Shneiderman aparecen en su libro \u201cDesigning the User Interface: Strategies for Effective Human-Computer Interaction\u201d.</p> <p></p> <p>A lo largo de las ediciones posteriores (ya van por la 6\u00aa edici\u00f3n, 2016, junto con Catherine Plaisant, Maxine Cohen y Steven Jacobs) las reglas se han mantenido como un marco b\u00e1sico de usabilidad, aunque complementadas con nuevos principios de dise\u00f1o, accesibilidad y experiencia de usuario.</p>"},{"location":"Bloque1_Ingenieria_Apps/accesibilidad_normativa/normativa/normativa/","title":"Normativa en Aplicaciones Web y M\u00f3viles","text":"<p>La accesibilidad digital est\u00e1 regulada por una serie de normas internacionales que garantizan el derecho de todas las personas a participar en igualdad de condiciones en la sociedad de la informaci\u00f3n. La referencia principal es la Web Content Accessibility Guidelines (WCAG), desarrolladas por el World Wide Web Consortium (W3C).  </p> <p>El cumplimiento de estas directrices es esencial en el desarrollo de aplicaciones web y m\u00f3viles, no solo por motivos legales, sino tambi\u00e9n \u00e9ticos y sociales. Aplicarlas mejora la experiencia de usuario, aumenta el alcance de los productos digitales y evita situaciones de exclusi\u00f3n.</p> <p> </p>"},{"location":"Bloque1_Ingenieria_Apps/accesibilidad_normativa/normativa/normativa/#principios-fundamentales-de-las-wcag","title":"Principios Fundamentales de las WCAG","text":"<p>Las WCAG se estructuran en torno a cuatro principios fundamentales, que forman la base de un dise\u00f1o inclusivo:</p> <ol> <li> <p>Perceptible: la informaci\u00f3n y los componentes de la interfaz deben presentarse de manera que los usuarios puedan percibirlos. </p> </li> <li> <p>Operable: la interfaz debe ser utilizable a trav\u00e9s de diferentes dispositivos y formas de interacci\u00f3n (teclado, voz, pantalla t\u00e1ctil, etc.). </p> </li> <li> <p>Comprensible: el contenido y el funcionamiento de la interfaz deben ser f\u00e1ciles de entender. </p> </li> <li> <p>Robusto: el contenido debe poder ser interpretado de forma fiable por una amplia variedad de agentes de usuario, incluidas las tecnolog\u00edas de apoyo. </p> </li> </ol>"},{"location":"Bloque1_Ingenieria_Apps/accesibilidad_normativa/normativa/normativa/#niveles-de-conformidad","title":"Niveles de Conformidad","text":"<p>Las WCAG definen tres niveles de conformidad que permiten medir el grado de accesibilidad alcanzado:</p> <ul> <li>Nivel A: requisitos m\u00ednimos que garantizan la accesibilidad b\u00e1sica.  </li> <li>Nivel AA: nivel intermedio, considerado est\u00e1ndar en la mayor\u00eda de legislaciones.  </li> <li>Nivel AAA: nivel m\u00e1s alto, que asegura la mejor experiencia inclusiva posible.  </li> </ul> <p> </p> <ul> <li>Nivel A (m\u00ednimo):</li> </ul>  Texto alternativo en im\u00e1genes <pre><code>&lt;img src=\"grafico.png\" alt=\"Gr\u00e1fico de barras comparando ventas de 2024 y 2025\"&gt;\n</code></pre>  Navegaci\u00f3n mediante teclado <pre><code>&lt;button onclick=\"alert('\u00a1Bot\u00f3n activado!')\"&gt;Haz clic o pulsa Enter&lt;/button&gt;\n</code></pre>  Evitar contenido parpadeante <pre><code>&lt;!-- Ejemplo correcto: imagen est\u00e1tica en lugar de un GIF que parpadea --&gt;\n&lt;img src=\"banner.png\" alt=\"Oferta especial sin animaci\u00f3n\"&gt;\n</code></pre> <ul> <li>Nivel AA (intermedio):</li> </ul>  Contraste de color suficiente (m\u00ednimo 4.5:1) <pre><code>&lt;style&gt;\n  body {\n    background-color: #ffffff; /* blanco */\n    color: #333333;            /* gris oscuro, contraste 15.3:1 */\n  }\n&lt;/style&gt;\n&lt;p&gt;Texto con contraste accesible sobre fondo blanco.&lt;/p&gt;\n</code></pre>  Subt\u00edtulos en v\u00eddeos pregrabados <pre><code>&lt;video controls&gt;\n  &lt;source src=\"clase.mp4\" type=\"video/mp4\"&gt;\n  &lt;track src=\"subtitulos.vtt\" kind=\"subtitles\" srclang=\"es\" label=\"Espa\u00f1ol\"&gt;\n&lt;/video&gt;\n</code></pre>  Etiquetas claras en formularios <pre><code>&lt;form&gt;\n  &lt;label for=\"email\"&gt;Correo electr\u00f3nico&lt;/label&gt;\n  &lt;input type=\"email\" id=\"email\" name=\"email\"&gt;\n\n  &lt;button type=\"submit\"&gt;Enviar&lt;/button&gt;\n&lt;/form&gt;\n</code></pre> <ul> <li>Nivel AAA (m\u00e1ximo):</li> </ul>  Lengua de signos en v\u00eddeos <pre><code>&lt;video controls&gt;\n  &lt;source src=\"charla.mp4\" type=\"video/mp4\"&gt;\n  &lt;track src=\"subtitulos.vtt\" kind=\"subtitles\" srclang=\"es\" label=\"Espa\u00f1ol\"&gt;\n&lt;/video&gt;\n\n&lt;!-- Al lado, se puede a\u00f1adir un video en lengua de signos --&gt;\n&lt;video controls width=\"300\"&gt;\n  &lt;source src=\"charla_signos.mp4\" type=\"video/mp4\"&gt;\n&lt;/video&gt;\n</code></pre>  Texto de f\u00e1cil lectura <pre><code>&lt;article&gt;\n  &lt;h2&gt;Explicaci\u00f3n en lectura f\u00e1cil&lt;/h2&gt;\n  &lt;p&gt;Un ordenador es una m\u00e1quina. Sirve para guardar y usar informaci\u00f3n. \n  Puede ayudarte a escribir, calcular y comunicarte.&lt;/p&gt;\n&lt;/article&gt;\n</code></pre>  Contraste reforzado <pre><code>&lt;style&gt;\n  .alto-contraste {\n    background-color: #000000; /* negro */\n    color: #ffffff;           /* blanco, contraste 21:1 */\n    font-size: 18px;\n  }\n&lt;/style&gt;\n\n&lt;p class=\"alto-contraste\"&gt;Texto con contraste m\u00e1ximo para mejorar la legibilidad.&lt;/p&gt;\n</code></pre>"},{"location":"Bloque1_Ingenieria_Apps/accesibilidad_normativa/normativa/normativa/#relevancia-legal-en-europa-y-espana","title":"Relevancia Legal en Europa y Espa\u00f1a","text":"<p>En la Uni\u00f3n Europea, la Directiva 2016/2102 establece la obligaci\u00f3n de que los sitios web y aplicaciones m\u00f3viles de los organismos p\u00fablicos cumplan con las WCAG 2.1 en nivel AA.  </p> <p>En Espa\u00f1a, esta directiva se transpone a trav\u00e9s del Real Decreto 1112/2018, que obliga a las administraciones p\u00fablicas y a determinados servicios de inter\u00e9s general a garantizar la accesibilidad digital.  </p> <p>Cumplir con la normativa no solo evita sanciones, sino que tambi\u00e9n promueve una sociedad m\u00e1s justa e inclusiva.</p> <p></p> <p>WCAG 2.1</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/","title":"Ciclo de Vida y Arquitectura de Aplicaciones M\u00f3viles","text":"<p>Selecciona un subtema del men\u00fa lateral.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/archivos_yml/","title":"Archivos <code>.yml</code> (YAML)","text":""},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/archivos_yml/#que-es-un-archivo-yml","title":"\u00bfQu\u00e9 es un archivo <code>.yml</code>?","text":"<p>Un archivo <code>.yml</code> (o <code>.yaml</code>) est\u00e1 escrito en YAML (YAML Ain\u2019t Markup Language), un formato de serializaci\u00f3n de datos dise\u00f1ado para ser legible por humanos. Se utiliza ampliamente en desarrollo de software para definir configuraciones, de forma jer\u00e1rquica y estructurada, mediante sangr\u00edas en lugar de llaves o corchetes (a diferencia de JSON o XML).</p> <p>Ejemplo b\u00e1sico de un <code>.yml</code>:</p> <pre><code>nombre: \"Mar\u00eda\"\nedad: 25\nhabilidades:\n  - Java\n  - Python\n  - SQL\nactivo: true\n</code></pre>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/archivos_yml/#caracteristicas-principales-de-yaml","title":"Caracter\u00edsticas principales de YAML","text":"<ul> <li>Usa sangr\u00eda para estructurar jerarqu\u00edas (en lugar de <code>{}</code> o <code>[]</code>).  </li> <li>Soporta tipos de datos comunes: cadenas, n\u00fameros, booleanos, listas y diccionarios.  </li> <li>Es f\u00e1cil de leer y escribir para humanos.  </li> <li>Es ampliamente soportado en frameworks, compiladores, int\u00e9rpretes y sistemas de automatizaci\u00f3n.  </li> </ul>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/archivos_yml/#uso-en-github-actions","title":"Uso en GitHub Actions","text":"<p>En GitHub Actions, los archivos <code>.yml</code> definen los workflows dentro de <code>.github/workflows/</code>.  </p> <p>Ejemplo: un flujo para compilar y ejecutar pruebas en Java:</p> <pre><code>name: Java CI\n\non: [push, pull_request]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Set up JDK\n        uses: actions/setup-java@v3\n        with:\n          java-version: '17'\n      - name: Build with Maven\n        run: mvn package\n</code></pre> <p>Aqu\u00ed, YAML estructura el flujo de trabajo mediante claves (<code>jobs</code>, <code>steps</code>, <code>uses</code>, <code>run</code>) que GitHub interpreta para ejecutar acciones.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/archivos_yml/#uso-en-github-fuera-de-actions","title":"Uso en GitHub (fuera de Actions)","text":"<p>Adem\u00e1s de Actions, GitHub usa <code>.yml</code> en otros contextos, por ejemplo:</p> <ul> <li>Dependabot (<code>.github/dependabot.yml</code>): gestiona actualizaciones autom\u00e1ticas de dependencias.  </li> <li>CodeQL (<code>.github/codeql.yml</code>): define an\u00e1lisis de seguridad.  </li> </ul>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/archivos_yml/#uso-en-compiladores-interpretes-y-otras-herramientas","title":"Uso en compiladores, int\u00e9rpretes y otras herramientas","text":"<p>Los archivos <code>.yml</code> no se limitan a GitHub. Muchos sistemas los utilizan como archivos de configuraci\u00f3n:</p> <ul> <li>Docker Compose: define servicios, redes y vol\u00famenes de contenedores. <pre><code>version: '3'\nservices:\n  web:\n    image: nginx\n    ports:\n      - \"80:80\"\n</code></pre></li> <li>Kubernetes: describe despliegues y servicios en un cl\u00faster.  </li> <li>CI/CD externos: como Travis CI o CircleCI.  </li> <li>Frameworks: Django, Spring Boot y muchos otros permiten configurar variables con <code>.yml</code>.  </li> </ul>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/archivos_yml/#conclusion","title":"Conclusi\u00f3n","text":"<p>Los archivos <code>.yml</code> son una herramienta esencial en el ecosistema del desarrollo moderno porque permiten describir configuraci\u00f3n compleja en un formato sencillo y legible. En el caso de GitHub Actions, son el pilar para definir los workflows de CI/CD; en otros entornos, son igualmente \u00fatiles para configuraci\u00f3n de entornos, despliegue de aplicaciones o integraci\u00f3n con servicios externos.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/arquitectura/","title":"Arquitectura de Aplicaciones M\u00f3viles","text":"<p>La arquitectura de una aplicaci\u00f3n m\u00f3vil define la organizaci\u00f3n interna de sus componentes y c\u00f3mo se comunican entre s\u00ed. Constituye el esqueleto que sostiene el desarrollo y mantenimiento de la app, asegurando escalabilidad, calidad y facilidad de evoluci\u00f3n. En el contexto de PAMN, comprender la arquitectura es fundamental para formar profesionales capaces de crear aplicaciones robustas y alineadas con las buenas pr\u00e1cticas de la industria.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/arquitectura/#objetivos-de-la-arquitectura","title":"Objetivos de la arquitectura","text":"<ul> <li>Proporcionar un marco estructurado para el desarrollo.  </li> <li>Asegurar la separaci\u00f3n de responsabilidades.  </li> <li>Facilitar la escalabilidad y la mantenibilidad.  </li> <li>Simplificar la integraci\u00f3n de nuevas funcionalidades.  </li> <li>Reforzar la seguridad y el control del proyecto.  </li> </ul>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/arquitectura/#por-que-es-importante","title":"\u00bfPor qu\u00e9 es importante?","text":"<p>Una buena arquitectura:</p> <ul> <li>Estructura: Una arquitectura s\u00f3lida proporciona un esqueleto robusto para el Proyecto, asegurando que cada componente encaje de manera coherente y eficiente. </li> </ul> <p></p> <ul> <li>Planificaci\u00f3n: Facilita la toma de decisiones anticipadas, permitiendo evitar posibles obst\u00e1culos y puntos cr\u00edticos en el desarrollo. </li> </ul> <p></p> <ul> <li>Control: Con una arquitectura bien definida, es  m\u00e1s sencillo monitorizar el progreso, identificar desviaciones  y garantizar que el Proyecto se mantenga en el camino correcto.</li> </ul> <p> </p> <ul> <li>Optimizaci\u00f3n del proceso: Una  buena arquitectura simplifica la integraci\u00f3n de nuevas caracter\u00edsticas y facilita las actualizaciones, asegurando la escalabilidad y adaptabilidad del Proyecto a largo plazo. </li> </ul> <p> </p> <ul> <li>Separaci\u00f3n de capas: Consiste en dividir un sistema en capas o m\u00f3dulos independientes, cada uno con una responsabilidad espec\u00edfica. Podemos distinguir entre presentaci\u00f3n, l\u00f3gica de negocio y gesti\u00f3n de datos.</li> </ul> <p> </p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/arquitectura/#modelos-de-arquitectura-mas-utilizados","title":"Modelos de arquitectura m\u00e1s utilizados","text":""},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/arquitectura/#1-mvc-modelovistacontrolador","title":"1. MVC (Modelo\u2013Vista\u2013Controlador)","text":"<p>Separa la app en tres componentes principales: modelo, vista y controlador. </p> <ul> <li>Modelo: Datos y l\u00f3gica de negocio.  </li> <li>Vista: Interfaz gr\u00e1fica.  </li> <li>Controlador: Act\u00faa como intermediario, manejando la entrada del usuario y actualizando tanto la vista como el modelo.  </li> </ul> <p>Ventajas: La separaci\u00f3n clara entre la l\u00f3gica de la interfaz de usuario y la l\u00f3gica de negocio. Inconvenientes: El controlador tiende a sobrecargarse en proyectos grandes. La vista y el controlador suelen estar m\u00e1s acoplados en en otras arquitecturas. </p> <p></p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/arquitectura/#2-mvp-modelovistapresentador","title":"2. MVP (Modelo\u2013Vista\u2013Presentador)","text":"<p>Separa la l\u00f3gica de presentaci\u00f3n de la l\u00f3gica de negocio.</p> <ul> <li>Modelo: Mantiene datos y reglas de negocio.  </li> <li>Vista: Muestra informaci\u00f3n, delega l\u00f3gica.  </li> <li>Presentador: Gestiona la l\u00f3gica de negocio y actualiza la vista.  </li> </ul> <p>Ventajas: La separaci\u00f3n clara entre la l\u00f3gica de la interfaz de usuario y la l\u00f3gica de negocio. Facilita una alta testabilidad. Inconvenientes: Puede generar c\u00f3digo m\u00e1s complejo.  </p> <p></p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/arquitectura/#3-mvvm-modelovistavistamodelo","title":"3. MVVM (Modelo\u2013Vista\u2013VistaModelo)","text":"<p>Arquitectura que utiliza un modelo de vista para gestionar la l\u00f3gica de la aplicaci\u00f3n.</p> <ul> <li>Modelo: Gestiona datos y l\u00f3gica de negocio.  </li> <li>Vista: Muestra la interfaz y se comunica con la vista modelo.  </li> <li>VistaModelo: Maneja la l\u00f3gica de presentaci\u00f3n y comunica vista y modelo.  </li> </ul> <p>Ventajas: menor acoplamiento y compatible con programaci\u00f3n reactiva.  </p> <p></p> <p>Modelo\u2013Vista\u2013VistaModelo (MVVM).</p>  Diferencias entre MVC, MVP y MVVM <p>1. MVC (Model\u2013View\u2013Controller)</p> <ul> <li>Controlador: act\u00faa como intermediario entre la vista y el modelo.</li> <li>Recibe la interacci\u00f3n del usuario, decide qu\u00e9 hacer y actualiza el modelo o la vista.</li> <li>La vista suele tener cierta l\u00f3gica, por lo que no est\u00e1 totalmente aislada.</li> <li>Problema: en apps complejas, el controlador tiende a crecer demasiado (Massive View Controller).</li> </ul> <p>2. MVP (Model\u2013View\u2013Presenter)</p> <ul> <li>Presentador: sustituye al controlador de MVC.</li> <li>Se encarga de la l\u00f3gica de presentaci\u00f3n: recibe eventos de la vista, consulta/actualiza el modelo y devuelve datos preparados.</li> <li>La vista queda m\u00e1s pasiva, mostrando \u00fanicamente lo que el presentador indica.</li> <li>Ventaja: mejor separaci\u00f3n de responsabilidades, vista m\u00e1s simple.</li> </ul> <p>3. MVVM (Model\u2013View\u2013ViewModel)</p> <ul> <li>Vista-Modelo: no conoce directamente la vista; expone datos observables (LiveData, StateFlow, etc.).</li> <li>La vista se suscribe a esos datos y se actualiza autom\u00e1ticamente cuando cambian.</li> <li>La l\u00f3gica de negocio de la UI se coloca en el ViewModel, y la vista solo reacciona.</li> <li>Ventaja: fuerte desacoplamiento y arquitectura reactiva, ideal para data binding.</li> </ul> <p> Diferencia clave:</p> <ul> <li>MVC: el controlador actualiza vista y modelo directamente (m\u00e1s acoplamiento).</li> <li>MVP: el presentador orquesta y la vista solo pinta (vista pasiva).</li> <li>MVVM: el ViewModel expone estado observable y la vista reacciona autom\u00e1ticamente (desacoplamiento m\u00e1ximo).</li> </ul>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/arquitectura/#4-mvi-modelovistaintencion","title":"4. MVI (Modelo\u2013Vista\u2013Intenci\u00f3n)","text":"<p>Se centra en la intenci\u00f3n del usuario y utiliza un flujo de datos unidireccional.</p> <ul> <li>Modelo: Datos y l\u00f3gica de negocio.  </li> <li>Vista: Muestra el estado actual de la aplicaci\u00f3n.  </li> <li>Intenciones: Representa las intenciones o acciones del usuario.   </li> </ul> <p>Ventaja principal: Enfoque c\u00edclico y reactivo que maneja el flujo de datos y eventos.  </p> <p></p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/arquitectura/#5-arquitectura-hexagonal","title":"5. Arquitectura Hexagonal","text":"<p>Divide la app en capas:</p> <ul> <li>N\u00facleo: Dominio que representa la l\u00f3gica de negocio.  </li> <li>Aplicaci\u00f3n: Maneja los casos de uso.  </li> <li>Infraestructura: Maneja los adaptadores de infraestructura, incluyendo los controladores (adaptadores que manejan la interfaz de usuario).  </li> </ul> <p>Los adaptadores se conectan a los puertos. El diagrama sigue el principio de desacoplamiento de la arquitectura hexagonal. La l\u00f3gica de negocio est\u00e1 completamente aislada de los detalles de implementaci\u00f3n externa (infraestructura, tecnolog\u00edas). Las interacciones entre la aplicaci\u00f3n y el mundo exterior se realizan a trav\u00e9s de puertos y adaptadores, lo que garantiza que el n\u00facleo del sistema sea independiente de la infraestructura. Este patr\u00f3n facilita el cambio de tecnolog\u00edas externas sin modificar el n\u00facleo, promueve la testabilidad y permite que cada componente sea mantenido y desarrollado de manera independiente.</p> <p></p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/arquitectura/#factores-para-elegir-la-arquitectura-consideraciones-clave","title":"Factores para elegir la arquitectura. Consideraciones clave.","text":"<ul> <li>Requerimientos: Entender las necesidades espec\u00edficas y objetivos del proyecto para determinar qu\u00e9 arquitectura se alinea mejor.</li> <li>Rendimiento: Evaluar c\u00f3mo cada arquitectura puede influir en la velocidad, respuesta y eficiencia del sistema.</li> <li>Integraci\u00f3n con otros Sistemas: Si el proyecto necesita interactuar con otros sistemas o aplicaciones, la arquitectura debe facilitar estas integraciones.</li> <li>Recursos: Evaluar la inversi\u00f3n necesaria en t\u00e9rminos de tiempo, dinero y recursos humanos para implementar y mantener</li> <li>Seguridad: Garantizar que la arquitectura elegida ofrezca las medidas de seguridad adecuadas para proteger datos y procesos.</li> <li>Facilidad de mantenimiento: La facilidad con la que se pueden hacer cambios, correcciones o mejoras en el sistema a lo largo del tiempo.</li> </ul>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/arquitectura/#estructurando-aplicaciones","title":"Estructurando aplicaciones.","text":""},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/arquitectura/#relacion-con-devops","title":"Relaci\u00f3n con DevOps","text":"<p>La arquitectura m\u00f3vil est\u00e1 alineada con la filosof\u00eda DevOps, ya que:  </p> <ul> <li>Favorece la automatizaci\u00f3n de pruebas e integraci\u00f3n continua.  </li> <li>Permite despliegues m\u00e1s r\u00e1pidos y seguros.  </li> <li>Mejora la observabilidad en producci\u00f3n.  </li> <li>Facilita la escalabilidad de las aplicaciones.  </li> </ul>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/arquitectura/#conclusiones","title":"Conclusiones","text":"<ul> <li>La arquitectura es el pilar central de una app m\u00f3vil.  </li> <li>Existen m\u00faltiples patrones (MVC, MVP, MVVM, MVI, Hexagonal), cada uno con pros y contras.  </li> <li>La elecci\u00f3n depende de los objetivos, recursos y contexto del proyecto.  </li> <li>Una arquitectura alineada con DevOps asegura calidad y entrega continua.  </li> </ul>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/ciclo_vida_devops/","title":"Ciclo de vida de una aplicaci\u00f3n m\u00f3vil y su relaci\u00f3n con DevOps","text":"<p>El ciclo de vida de una aplicaci\u00f3n m\u00f3vil describe todas las fases que atraviesa una app desde su concepci\u00f3n hasta su retirada. Comprender este ciclo permite desarrollar soluciones m\u00e1s robustas, escalables y mantenibles, optimizando recursos y minimizando errores. En el contexto de PAMN, este enfoque es esencial para preparar al estudiante en entornos reales de desarrollo.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/ciclo_vida_devops/#objetivos-del-ciclo-de-vida","title":"Objetivos del ciclo de vida","text":"<ul> <li>Establecer un marco ordenado para el desarrollo.</li> <li>Identificar y controlar riesgos desde fases tempranas.</li> <li>Asegurar la calidad del producto desde su dise\u00f1o.</li> <li>Permitir una entrega continua y sostenible.</li> </ul>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/ciclo_vida_devops/#breve-historia","title":"Breve historia","text":"<p>Inicialmente, el ciclo de vida del software segu\u00eda modelos r\u00edgidos como el modelo en cascada, donde cada fase deb\u00eda completarse antes de pasar a la siguiente. Con la evoluci\u00f3n de las metodolog\u00edas \u00e1giles, se impuso una visi\u00f3n iterativa e incremental del desarrollo, y con la llegada del desarrollo m\u00f3vil surgieron nuevas necesidades: integraci\u00f3n continua, automatizaci\u00f3n, despliegue frecuente y monitorizaci\u00f3n en tiempo real. Es aqu\u00ed donde emerge DevOps, una pr\u00e1ctica que unifica el desarrollo (Dev) y las operaciones (Ops).</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/ciclo_vida_devops/#devops-como-interseccion-de-disciplinas","title":"DevOps como intersecci\u00f3n de disciplinas","text":"<p>La imagen anterior representa la integraci\u00f3n de tres dimensiones fundamentales: desarrollo, operaciones y control de calidad. El \u00e1rea donde se superponen da lugar al enfoque DevOps, que busca romper los silos tradicionales, fomentar la colaboraci\u00f3n entre equipos y automatizar todo lo posible para entregar valor de forma continua al usuario final.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/ciclo_vida_devops/#el-ciclo-devops-en-accion","title":"El ciclo DevOps en acci\u00f3n","text":"<p>Este diagrama muestra el flujo t\u00edpico de un proceso DevOps, en forma de bucle infinito. Cada etapa est\u00e1 conectada a la siguiente, favoreciendo una entrega continua e integraci\u00f3n constante. Las fases principales son:</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/ciclo_vida_devops/#1-planificacion","title":"1. Planificaci\u00f3n","text":"<p>Definici\u00f3n de requisitos, tareas y objetivos. Se pueden utilizar herramientas como Jira, Trello o Azure Boards.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/ciclo_vida_devops/#2-codificacion","title":"2. Codificaci\u00f3n","text":"<p>Desarrollo de funcionalidades. Aqu\u00ed se emplean lenguajes como Kotlin, Swift, Dart, Java o frameworks como React Native. Herramientas: Android Studio, Xcode, VS Code.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/ciclo_vida_devops/#3-compilacion","title":"3. Compilaci\u00f3n","text":"<p>Generaci\u00f3n de artefactos ejecutables. Herramientas comunes: Gradle, Maven, Xcode Build.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/ciclo_vida_devops/#4-pruebas","title":"4. Pruebas","text":"<p>Ejecutadas de forma automatizada o manual. Destacan frameworks como JUnit, Espresso, XCTest, o pruebas E2E con Appium.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/ciclo_vida_devops/#5-publicacion","title":"5. Publicaci\u00f3n","text":"<p>Subida a tiendas como Google Play o App Store. Automatizable con Fastlane, GitHub Actions, Bitrise.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/ciclo_vida_devops/#6-despliegue","title":"6. Despliegue","text":"<p>Distribuci\u00f3n en entornos de producci\u00f3n o pruebas (alpha, beta). Puede hacerse v\u00eda Firebase App Distribution o TestFlight.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/ciclo_vida_devops/#7-monitorizacion","title":"7. Monitorizaci\u00f3n","text":"<p>An\u00e1lisis del rendimiento y errores. Herramientas t\u00edpicas: Firebase Crashlytics, Sentry, New Relic.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/ciclo_vida_devops/#8-operaciones","title":"8. Operaciones","text":"<p>Gesti\u00f3n de la infraestructura, soporte y mantenimiento. Se apoyan en CI/CD (GitHub Actions, GitLab CI, Jenkins) e infraestructura como c\u00f3digo (IaC).</p> <p>GitHub actions</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/github_actions/","title":"GitHub Actions","text":""},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/github_actions/#que-es-github-actions","title":"\u00bfQu\u00e9 es GitHub Actions?","text":"<p>GitHub Actions es una herramienta integrada en GitHub que permite automatizar flujos de trabajo directamente en los repositorios. Se basa en la idea de ejecutar tareas desencadenadas por eventos (como push, pull request, creaci\u00f3n de issues, etc.) usando workflows definidos en ficheros YAML.</p> <p>Con GitHub Actions puedes construir, probar, desplegar y mantener tu proyecto sin necesidad de servicios externos.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/github_actions/#beneficios-principales","title":"Beneficios principales","text":"<ul> <li>Integraci\u00f3n nativa con GitHub: no necesitas configurar servicios adicionales.  </li> <li>Automatizaci\u00f3n de procesos repetitivos: pruebas, compilaciones, despliegues, etc.  </li> <li>Soporte multiplataforma: ejecuta jobs en Linux, Windows y macOS.  </li> <li>Flexibilidad: puedes crear tus propios actions o reutilizar los que comparte la comunidad.  </li> <li>Escalabilidad: ideal tanto para proyectos peque\u00f1os como para grandes entornos de desarrollo.  </li> </ul>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/github_actions/#rol-en-cicd","title":"Rol en CI/CD","text":"<p>GitHub Actions se utiliza para implementar Integraci\u00f3n Continua (CI) y Despliegue Continuo (CD):</p> <ul> <li>CI (Continuous Integration): cada vez que un desarrollador sube cambios, se ejecutan autom\u00e1ticamente compilaciones y pruebas para verificar que el c\u00f3digo sigue funcionando.  </li> <li>CD (Continuous Deployment/Delivery): despu\u00e9s de pasar las pruebas, los cambios pueden desplegarse autom\u00e1ticamente en entornos de pruebas o producci\u00f3n.  </li> </ul> <p>Esto garantiza una entrega m\u00e1s r\u00e1pida y confiable del software.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/github_actions/#para-que-se-utiliza","title":"\u00bfPara qu\u00e9 se utiliza?","text":"<ul> <li>Compilar c\u00f3digo autom\u00e1ticamente despu\u00e9s de cada push.  </li> <li>Ejecutar tests unitarios y de integraci\u00f3n en distintos entornos.  </li> <li>Generar artefactos (ejecutables, librer\u00edas, documentaci\u00f3n).  </li> <li>Desplegar aplicaciones en servidores, contenedores Docker o servicios en la nube.  </li> <li>Automatizar tareas de mantenimiento como cerrar issues, etiquetar releases o enviar notificaciones.  </li> </ul>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/github_actions/#como-se-utiliza","title":"\u00bfC\u00f3mo se utiliza?","text":"<p>Los workflows de GitHub Actions se definen en ficheros YAML dentro de la carpeta:</p> <pre><code>.github/workflows/\n</code></pre> <p>Cada workflow est\u00e1 compuesto por:</p> <ul> <li>Eventos: disparadores que inician el flujo (ej. <code>push</code>, <code>pull_request</code>).  </li> <li>Jobs: tareas que se ejecutan, cada una en una m\u00e1quina virtual.  </li> <li>Steps: pasos dentro de un job (instalar dependencias, ejecutar scripts, etc.).  </li> <li>Actions: comandos predefinidos o personalizados reutilizables.  </li> </ul>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/github_actions/#ejemplos-practicos","title":"Ejemplos pr\u00e1cticos","text":""},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/github_actions/#ejemplo-1-compilar-y-ejecutar-pruebas-en-java","title":"Ejemplo 1: Compilar y ejecutar pruebas en Java","text":"<pre><code>name: Java CI\n\non: [push, pull_request]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v3\n    - name: Set up JDK 17\n      uses: actions/setup-java@v3\n      with:\n        java-version: '17'\n        distribution: 'temurin'\n    - name: Build with Maven\n      run: mvn -B package --file pom.xml\n    - name: Run tests\n      run: mvn test\n</code></pre>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/github_actions/#ejemplo-2-desplegar-en-github-pages","title":"Ejemplo 2: Desplegar en GitHub Pages","text":"<pre><code>name: Deploy to GitHub Pages\n\non:\n  push:\n    branches: [ main ]\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v3\n    - name: Build static site\n      run: |\n        npm install\n        npm run build\n    - name: Deploy\n      uses: peaceiris/actions-gh-pages@v3\n      with:\n        github_token: ${{ secrets.GITHUB_TOKEN }}\n        publish_dir: ./dist\n</code></pre> <p>Gesti\u00f3n de GitHub Actions</p> <p>Kotlin</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/github_actions/#conclusion","title":"Conclusi\u00f3n","text":"<p>GitHub Actions convierte a GitHub en una plataforma completa de desarrollo, donde adem\u00e1s de almacenar el c\u00f3digo puedes compilarlo, probarlo y desplegarlo autom\u00e1ticamente. Facilita la colaboraci\u00f3n en equipo, reduce errores humanos y acelera la entrega de software gracias a la integraci\u00f3n CI/CD.</p> <p>Despliegue de Aplicaciones M\u00f3viles</p> <p>Despliegue Comentados</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/github_actions_gestion/","title":"Gesti\u00f3n de GitHub Actions","text":""},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/github_actions_gestion/#que-es-el-cache-en-github-actions","title":"\u00bfQu\u00e9 es el cach\u00e9 en GitHub Actions?","text":"<p>Es un almacenamiento temporal que guardan los runners de GitHub para evitar descargar o volver a construir dependencias en cada ejecuci\u00f3n.</p> <p>Similar a la instalaci\u00f3n de dependencias con <code>npm install</code>, <code>pip install</code>, <code>gradle build</code> o <code>maven</code>. Normalmente eso se descarga cada vez que corre el workflow, lo que lo hace lento.</p> <p>Con la cach\u00e9, esos archivos (ej. <code>.m2/repository</code>, <code>~/.gradle/caches</code>, <code>node_modules</code>) se guardan en GitHub y se reutilizan en siguientes ejecuciones.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/github_actions_gestion/#para-que-se-utiliza","title":"\ud83d\udd39 \u00bfPara qu\u00e9 se utiliza?","text":"<ul> <li>Acelerar workflows: reduce tiempos de compilaci\u00f3n y test.  </li> <li>Ahorrar ancho de banda: menos descargas de dependencias externas.  </li> <li>Reutilizar entornos: \u00fatil en builds grandes (ejemplo: proyectos Android con Gradle).  </li> </ul>  Cache  <p>El cach\u00e9 en GitHub Actions es como una mochila que guarda las dependencias y resultados intermedios entre ejecuciones, para que los workflows sean mucho m\u00e1s r\u00e1pidos y eficientes.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/github_actions_gestion/#que-son-los-deployments-en-github-actions","title":"\u00bfQu\u00e9 son los Deployments en GitHub Actions?","text":"<p>Los deployments (despliegues) en GitHub Actions representan el proceso de publicar o entregar software a un entorno espec\u00edfico: pruebas, staging, producci\u00f3n, etc. Permiten que tu c\u00f3digo no solo se compile y se pruebe, sino que tambi\u00e9n llegue de forma controlada a los usuarios finales o a los servidores donde se ejecuta.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/github_actions_gestion/#caracteristicas-principales","title":"\ud83d\udd39 Caracter\u00edsticas principales","text":"<ul> <li>Entornos (Environments): GitHub permite definir entornos como <code>staging</code> o <code>production</code> con reglas, revisores y protecciones.  </li> <li>Hist\u00f3rico de despliegues: cada deployment queda registrado, facilitando auditor\u00eda y rollback.  </li> <li>Permisos y secretos: puedes definir secretos distintos por entorno, garantizando seguridad en credenciales (ej. claves de AWS, Firebase, Play Store).  </li> <li>Integraci\u00f3n con flujos CI/CD: se enlazan a los jobs finales de un workflow, tras pasar por build y test.</li> </ul>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/github_actions_gestion/#para-que-se-utilizan","title":"\ud83d\udd39 \u00bfPara qu\u00e9 se utilizan?","text":"<ul> <li>Publicar una aplicaci\u00f3n web en GitHub Pages, Netlify o Vercel.  </li> <li>Subir un contenedor Docker a DockerHub o GitHub Container Registry.  </li> <li>Distribuir aplicaciones m\u00f3viles a Firebase App Distribution, Google Play o TestFlight.  </li> <li>Desplegar microservicios a AWS, Azure, GCP o Kubernetes.  </li> </ul>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/github_actions_gestion/#ejemplo-simple-desplegar-a-github-pages","title":"\ud83d\udd39 Ejemplo simple (desplegar a GitHub Pages)","text":"<pre><code>name: Deploy website\non:\n  push:\n    branches: [ main ]\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Build site\n        run: |\n          npm install\n          npm run build\n      - name: Deploy to GitHub Pages\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          publish_dir: ./build\n</code></pre> <p>En este caso, cada vez que se hace push a <code>main</code>, el sitio se compila y se publica autom\u00e1ticamente en GitHub Pages.</p>  Deployments  <p>Los deployments permiten llevar tu aplicaci\u00f3n m\u00e1s all\u00e1 de la compilaci\u00f3n y las pruebas: son el paso en que tu software pasa a estar disponible en un entorno real o para usuarios.   En GitHub Actions, se gestionan mediante jobs configurados para distintos entornos, con control de permisos, secretos y registros de auditor\u00eda.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/github_actions_gestion/#que-son-las-attestations-en-github-actions","title":"\u00bfQu\u00e9 son las Attestations en GitHub Actions?","text":"<p>Las attestations (atestaciones) son pruebas criptogr\u00e1ficas que vinculan un artefacto (p. ej., un binario, imagen Docker, paquete) con c\u00f3mo y d\u00f3nde fue generado (workflow, commit, runner, identidad OIDC). Su objetivo es mejorar la seguridad de la cadena de suministro (Supply Chain Security) proporcionando provenance (procedencia) verificable, alineada con est\u00e1ndares como SLSA.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/github_actions_gestion/#para-que-se-utilizan_1","title":"\ud83d\udd39 \u00bfPara qu\u00e9 se utilizan?","text":"<ul> <li>Trazabilidad y confianza: demostrar que un artefacto proviene de un pipeline controlado y de un commit concreto.</li> <li>Cumplimiento: requisitos de compliance (p. ej., pol\u00edticas internas o clientes que exigen provenance).</li> <li>Verificaci\u00f3n antes del despliegue: pol\u00edticas que bloquean despliegues si el artefacto no tiene una atestaci\u00f3n v\u00e1lida.</li> </ul>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/github_actions_gestion/#conceptos-clave","title":"\ud83d\udd39 Conceptos clave","text":"<ul> <li>Provenance (SLSA): metadatos firmados que describen c\u00f3mo se construy\u00f3 el artefacto (fuente, builder, par\u00e1metros, hash).</li> <li>Firmas: se apoyan en identidad OIDC del workflow y claves gestionadas por GitHub para impedir suplantaciones.</li> <li>Almacenamiento/consulta: las atestaciones quedan asociadas al artefacto en GitHub y pueden verificarse en tiempo de despliegue.</li> </ul>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/github_actions_gestion/#ejemplo-slsa-build-provenance-para-un-binario-o-paquete","title":"\ud83d\udd39 Ejemplo (SLSA build provenance para un binario o paquete)","text":"<p>Genera una atestaci\u00f3n de procedencia para los archivos construidos en <code>dist/</code>.</p> <p><pre><code>name: Build with provenance\non:\n  push:\n    tags: [ 'v*' ]\n\npermissions:\n  contents: read\n  id-token: write   # Necesario para atestaciones (OIDC)\n  attestations: write\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - name: Build\n        run: |\n          mkdir -p dist\n          echo \"hello\" &gt; dist/app.txt\n\n      - name: Attest build provenance (SLSA)\n        uses: actions/attest-build-provenance@v1\n        with:\n          subject-path: 'dist/*'   # Archivos a atestar (los artefactos)\n</code></pre> C\u00f3mo funciona: la acci\u00f3n genera una atestaci\u00f3n SLSA que vincula los artefactos en <code>dist/*</code> con este workflow/commit. Esa prueba se puede verificar antes de desplegar.</p>  Attestations  <p>Las attestations son metadatos firmados que prueban qui\u00e9n, c\u00f3mo y desde qu\u00e9 c\u00f3digo se construy\u00f3 un artefacto. En GitHub Actions se generan con acciones como <code>actions/attest-build-provenance</code> y se apoyan en OIDC para proporcionar una identidad verificable.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/github_actions_gestion/#que-son-los-runners-en-github-actions","title":"\u00bfQu\u00e9 son los Runners en GitHub Actions?","text":"<p>Los runners son las m\u00e1quinas (hosted o self-hosted) donde se ejecutan los jobs de tus workflows. Cada job declara su \u201cdestino\u201d con <code>runs-on</code> (por ejemplo, <code>ubuntu-latest</code>).</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/github_actions_gestion/#tipos-de-runners","title":"\ud83d\udd39 Tipos de runners","text":"<ul> <li>GitHub-hosted runners: m\u00e1quinas ef\u00edmeras gestionadas por GitHub (Ubuntu, Windows, macOS).  </li> <li>Ventajas: cero mantenimiento, listos para uso, limpieza por job.  </li> <li>Ejemplos: <code>ubuntu-latest</code>, <code>windows-latest</code>, <code>macos-latest</code>.  </li> <li>Self-hosted runners: m\u00e1quinas que t\u00fa administras (on-premise o cloud) y que registras en tu repo/organizaci\u00f3n.  </li> <li>Ventajas: control total, hardware especializado (GPU), acceso a redes internas.  </li> <li>Requiere mantenimiento, actualizaci\u00f3n y seguridad propias.</li> </ul>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/github_actions_gestion/#seleccion-por-etiquetas-labels","title":"\ud83d\udd39 Selecci\u00f3n por etiquetas (labels)","text":"<ul> <li><code>runs-on</code> acepta una etiqueta (p. ej. <code>ubuntu-latest</code>) o varias (para self-hosted se usan combinadas).  </li> <li>Puedes agrupar runners y asignar etiquetas como <code>self-hosted</code>, <code>linux</code>, <code>gpu</code>, <code>arm64</code> para enrutar jobs.</li> </ul> <pre><code># GitHub-hosted\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n      - run: echo \"Hello from GitHub-hosted runner\"\n</code></pre> <pre><code># Self-hosted con etiquetas\njobs:\n  build:\n    runs-on: [ self-hosted, linux, x64 ]\n    steps:\n      - uses: actions/checkout@v4\n      - run: ./gradlew build\n</code></pre>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/github_actions_gestion/#buenas-practicas-y-opciones-utiles","title":"\ud83d\udd39 Buenas pr\u00e1cticas y opciones \u00fatiles","text":"<ul> <li>Concurrencia y timeouts para evitar jobs colgados: <pre><code>concurrency: project-ci-${{ github.ref }}\njobs:\n  build:\n    runs-on: ubuntu-latest\n    timeout-minutes: 30\n</code></pre></li> <li>Matriz de estrategias para probar m\u00faltiples entornos: <pre><code>jobs:\n  test:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        java: [17, 21]\n        os: [ubuntu-latest, windows-latest]\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-java@v4\n        with:\n          distribution: temurin\n          java-version: ${{ matrix.java }}\n      - run: ./gradlew test\n</code></pre></li> <li>Seguridad en self-hosted: ejecutar como usuarios con privilegios m\u00ednimos, aislar en redes, rotar tokens/labels, y actualizar el agente con frecuencia.</li> </ul>  Runners  <p>Un runner es la m\u00e1quina que ejecuta tus jobs. GitHub te ofrece runners hospedados listos para usar, o puedes registrar los tuyos (self-hosted) si necesitas hardware o red espec\u00edficos. Se seleccionan con <code>runs-on</code> y etiquetas.</p> <p>Ejemplo pr\u00e1ctico</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/github_actions_kotlin/","title":"GitHub Actions (Kotlin con comentarios)","text":""},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/github_actions_kotlin/#ejemplos-practicos","title":"Ejemplos pr\u00e1cticos","text":""},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/github_actions_kotlin/#ejemplo-1-compilar-y-ejecutar-pruebas-en-kotlin-gradle","title":"Ejemplo 1: Compilar y ejecutar pruebas en Kotlin (Gradle)","text":"<pre><code># Nombre del workflow\nname: Kotlin CI\n\n# Eventos que disparan el workflow: cada push o pull request\non: [push, pull_request]\n\njobs:\n  build:\n    # El job se ejecuta en un runner de Ubuntu (m\u00e1quina virtual proporcionada por GitHub)\n    runs-on: ubuntu-latest\n\n    steps:\n      # Paso 1: Descargar el c\u00f3digo fuente del repositorio\n      - uses: actions/checkout@v4\n\n      # Paso 2: Configurar JDK 17 con la distribuci\u00f3n Temurin\n      - name: Set up JDK 17\n        uses: actions/setup-java@v4\n        with:\n          java-version: '17'\n          distribution: 'temurin'\n\n      # Paso 3: Configurar Gradle y habilitar cach\u00e9 autom\u00e1tica de dependencias\n      - name: Setup Gradle\n        uses: gradle/actions/setup-gradle@v3\n\n      # Paso 4: Compilar el proyecto con Gradle\n      - name: Build with Gradle\n        run: ./gradlew build --stacktrace\n\n      # Paso 5: Ejecutar los tests definidos en el proyecto\n      - name: Run tests\n        run: ./gradlew test\n</code></pre>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/github_actions_kotlin/#ejemplo-2-desplegar-en-github-pages-kotlinjs-o-dokka","title":"Ejemplo 2: Desplegar en GitHub Pages (Kotlin/JS o Dokka)","text":"<p>Este ejemplo asume que el proyecto genera un sitio est\u00e1tico con Gradle en la carpeta <code>build/distributions</code> (para Kotlin/JS) o <code>build/dokka/html</code> (para documentaci\u00f3n con Dokka). Ajusta <code>publish_dir</code> seg\u00fan corresponda.</p> <pre><code># Nombre del workflow\nname: Deploy Kotlin site to GitHub Pages\n\n# Evento: se ejecuta al hacer push en la rama \"main\"\non:\n  push:\n    branches: [ main ]\n\njobs:\n  deploy:\n    # El job se ejecuta en un runner Ubuntu\n    runs-on: ubuntu-latest\n\n    steps:\n      # Paso 1: Descargar el c\u00f3digo fuente\n      - uses: actions/checkout@v4\n\n      # Paso 2: Configurar JDK 17 (necesario para ejecutar Gradle)\n      - name: Set up JDK 17\n        uses: actions/setup-java@v4\n        with:\n          java-version: '17'\n          distribution: 'temurin'\n\n      # Paso 3: Configurar Gradle y habilitar cach\u00e9 autom\u00e1tica\n      - name: Setup Gradle\n        uses: gradle/actions/setup-gradle@v3\n\n      # Paso 4: Compilar/generar el sitio est\u00e1tico con Gradle\n      - name: Build static site\n        run: ./gradlew build\n\n      # Paso 5: Publicar el contenido generado en GitHub Pages\n      - name: Deploy\n        uses: peaceiris/actions-gh-pages@v3\n        with:\n          # Token de autenticaci\u00f3n proporcionado autom\u00e1ticamente por GitHub\n          github_token: ${{ secrets.GITHUB_TOKEN }}\n          # Directorio con el sitio est\u00e1tico generado\n          publish_dir: ./build/distributions\n</code></pre>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/mvvm/","title":"Modelo\u2013Vista\u2013VistaModelo (MVVM)","text":""},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/mvvm/#1-crear-el-modelo-model","title":"1. Crear el modelo (Model)","text":"<p>El modelo representa la capa de datos de la aplicaci\u00f3n. Esta capa se encarga de manejar la l\u00f3gica de negocio, interactuar con bases de datos o servicios externos y proporcionar los datos que necesita la interfaz de usuario.</p> <pre><code>// Model.kt\ndata class User(val id: Int, val name: String, val age: Int)\n\n// Puede ser una clase de repositorio que maneja la obtenci\u00f3n de datos\nclass UserRepository {\n\n    private val userList = listOf(\n        User(1, \"John Doe\", 30),\n        User(2, \"Jane Smith\", 25)\n    )\n\n    // Simulamos la obtenci\u00f3n de los datos\n    fun getUsers(): List&lt;User&gt; = userList\n}\n</code></pre>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/mvvm/#2-crear-la-vista-modelo-viewmodel","title":"2. Crear la vista modelo (ViewModel)","text":"<p>La VistaModelo es el intermediario entre el Modelo y la Vista. Proporciona los datos de forma que la vista pueda observar los cambios y actualizarse autom\u00e1ticamente cuando los datos cambien. Utilizamos LiveData para hacer la comunicaci\u00f3n entre el ViewModel y la Vista, de forma que la Vista observe los cambios y reaccione autom\u00e1ticamente.</p> <pre><code>// UserViewModel.kt\nimport androidx.lifecycle.LiveData\nimport androidx.lifecycle.MutableLiveData\nimport androidx.lifecycle.ViewModel\n\nclass UserViewModel : ViewModel() {\n\n    private val userRepository = UserRepository()\n\n    // MutableLiveData que puede ser observada por la vista\n    private val _users = MutableLiveData&lt;List&lt;User&gt;&gt;()\n\n    // Exponemos los datos como LiveData, para que la vista observe los cambios\n    val users: LiveData&lt;List&lt;User&gt;&gt;\n        get() = _users\n\n    // Cargar los usuarios y actualizar el LiveData\n    fun loadUsers() {\n        val usersFromRepo = userRepository.getUsers()\n        _users.value = usersFromRepo\n    }\n}\n</code></pre>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/mvvm/#2-crear-la-vista-view","title":"2. Crear la vista (View)","text":"<p>La Vista en Android puede ser una Activity, un Fragment o cualquier componente de la interfaz que observe el ViewModel. En este caso, usaremos una Activity que observar\u00e1 los cambios del ViewModel y reaccionar\u00e1 en consecuencia. Aqu\u00ed es donde entrar\u00eda el uso de DataBinding para hacer el enlace de datos entre el ViewModel y la Vista.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/mvvm/#1-habilitamos-databinding-en-el-archivo-buildgradle","title":"1. Habilitamos Databinding en el archivo build.gradle:","text":"<pre><code>android {\n    ...\n    buildFeatures {\n        dataBinding true\n    }\n}\n</code></pre>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/mvvm/#2-creamos-el-layout-xml-con-el-enlace-de-datos-al-viewmodel","title":"2. Creamos el layout XML con el enlace de datos al ViewModel:","text":"<pre><code>&lt;!-- activity_main.xml --&gt;\n&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;\n\n    &lt;data&gt;\n        &lt;!-- Vinculamos el ViewModel --&gt;\n        &lt;variable\n            name=\"viewModel\"\n            type=\"com.example.mvvmexample.UserViewModel\" /&gt;\n    &lt;/data&gt;\n\n    &lt;LinearLayout\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\"&gt;\n\n        &lt;TextView\n            android:id=\"@+id/userText\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Users\" /&gt;\n\n        &lt;ListView\n            android:id=\"@+id/userListView\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\" /&gt;\n    &lt;/LinearLayout&gt;\n&lt;/layout&gt;\n</code></pre>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/mvvm/#3-implementamos-la-activity-que-observara-el-viewmodel","title":"3. Implementamos la activity que observar\u00e1 el ViewModel:","text":"<pre><code>// MainActivity.kt\nimport android.os.Bundle\nimport androidx.activity.viewModels\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.databinding.DataBindingUtil\nimport androidx.lifecycle.Observer\nimport com.example.mvvmexample.databinding.ActivityMainBinding\n\nclass MainActivity : AppCompatActivity() {\n\n    // Instanciamos el ViewModel usando la funci\u00f3n por defecto\n    private val userViewModel: UserViewModel by viewModels()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        // Enlazamos el layout con DataBinding\n        val binding: ActivityMainBinding =\n            DataBindingUtil.setContentView(this, R.layout.activity_main)\n\n        // Asignamos el ViewModel a la vista\n        binding.viewModel = userViewModel\n        binding.lifecycleOwner = this // Para que el binding observe los cambios\n\n        // Observamos el LiveData del ViewModel\n        userViewModel.users.observe(this, Observer { users -&gt;\n            // Actualizamos la interfaz cuando los datos cambian\n            binding.userText.text = users.joinToString { it.name }\n        })\n\n        // Cargar los datos en el ViewModel\n        userViewModel.loadUsers()\n    }\n}\n</code></pre>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/workflows_mobile_ci/","title":"Workflows CI/CD para Apps Nativas (Android &amp; iOS)","text":"<p>Para una app nativa tiene sentido usar CI con GitHub Actions porque asegura que cada cambio en el c\u00f3digo se compile, se pruebe y se valide autom\u00e1ticamente, evitando errores antes de llegar a los testers o a la tienda, y garantizando entregas r\u00e1pidas y confiables. Es evidente que este es el motivo por el que cualquier aplicaci\u00f3n deber\u00eda seguir estos pasos. En una App m\u00f3vil hay que tener en cuenta que: las tiendas (Google Play / App Store) son muy estrictas, y cada build debe estar firmada, validada y generada con las herramientas oficiales. Con CI (p. ej. GitHub Actions) puedes automatizar esa preparaci\u00f3n (firma, empaquetado, subida a tracks o TestFlight), algo que ser\u00eda tedioso y propenso a fallos si se hiciera manualmente.</p> <p>Es decir, adem\u00e1s de compilar y testear, en m\u00f3vil CI resuelve el cuello de botella del despliegue en tiendas.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/workflows_mobile_ci/#android-kotlin-gradle-build-tests-firebase-app-distribution-y-google-play-tracks","title":"Android (Kotlin, Gradle) --- build, tests, Firebase App Distribution y Google Play (tracks)","text":"<pre><code>name: Android CI\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n\njobs:\n  build-and-unit-tests:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: read\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n\n      - name: Set up Java 17\n        uses: actions/setup-java@v4\n        with:\n          distribution: temurin\n          java-version: 17\n\n      - name: Setup Gradle\n        uses: gradle/gradle-build-action@v3\n\n      - name: Setup Android SDK\n        uses: android-actions/setup-android@v3\n\n      - name: Build (assemble + unit tests)\n        run: ./gradlew clean assembleDebug testDebugUnitTest --stacktrace\n\n  android-instrumented-tests:\n    runs-on: macos-latest\n    needs: build-and-unit-tests\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-java@v4\n        with:\n          distribution: temurin\n          java-version: 17\n      - name: Setup Gradle\n        uses: gradle/gradle-build-action@v3\n\n      - name: Run UI tests on emulator\n        uses: reactivecircus/android-emulator-runner@v2\n        with:\n          api-level: 34\n          arch: x86_64\n          profile: pixel_6\n          script: ./gradlew connectedDebugAndroidTest\n\n  distribute-firebase:\n    runs-on: ubuntu-latest\n    needs: build-and-unit-tests\n    if: github.ref == 'refs/heads/main'\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-java@v4\n        with:\n          distribution: temurin\n          java-version: 17\n      - uses: gradle/gradle-build-action@v3\n      - name: Build release\n        run: ./gradlew clean bundleRelease\n      - name: Upload to Firebase App Distribution\n        env:\n          FIREBASE_TOKEN: ${{ secrets.FIREBASE_TOKEN }}\n        run: |\n          ./gradlew appDistributionUploadRelease             -PfirebaseServiceCredentialsFile=$GITHUB_WORKSPACE/fastlane/firebase-service-account.json             -PfirebaseTesters=\"${{ vars.FIREBASE_TESTERS }}\"             -PfirebaseReleaseNotes=\"CI upload from $GITHUB_SHA\"\n\n  publish-play-internal:\n    runs-on: ubuntu-latest\n    needs: build-and-unit-tests\n    if: startsWith(github.ref, 'refs/tags/v')\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-java@v4\n        with:\n          distribution: temurin\n          java-version: 17\n      - uses: gradle/gradle-build-action@v3\n      - name: Build AAB\n        run: ./gradlew clean bundleRelease\n      - name: Publish to Play (internal track) via GPP\n        env:\n          PLAY_SERVICE_ACCOUNT_JSON: ${{ secrets.PLAY_SERVICE_ACCOUNT_JSON }}\n        run: |\n          ./gradlew publishRelease             -Pandroid.injected.signing.store.file=$GITHUB_WORKSPACE/keystore.jks             -Pandroid.injected.signing.store.password=${{ secrets.SIGNING_STORE_PASSWORD }}             -Pandroid.injected.signing.key.alias=${{ secrets.SIGNING_KEY_ALIAS }}             -Pandroid.injected.signing.key.password=${{ secrets.SIGNING_KEY_PASSWORD }}             -Pplay.serviceAccountCredentials=$GITHUB_WORKSPACE/play-sa.json             -Pplay.track=internal\n          echo '${{ secrets.PLAY_SERVICE_ACCOUNT_JSON }}' &gt; play-sa.json\n</code></pre>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/workflows_mobile_ci/#ios-swift-o-kotlin-multiplatform-ios-build-unit-tests-testflight","title":"iOS (Swift o Kotlin Multiplatform iOS) --- build + unit tests + TestFlight","text":"<pre><code>name: iOS CI\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n  workflow_dispatch:\n\njobs:\n  build-test-upload:\n    runs-on: macos-latest\n    timeout-minutes: 60\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n\n      - name: Show Xcode version\n        run: xcodebuild -version\n\n      - name: Set up Ruby &amp; Bundler\n        run: |\n          gem install bundler:2.5.10\n          gem install fastlane --no-document\n\n      - name: Build &amp; unit tests\n        run: |\n          xcodebuild             -scheme \"App\"             -sdk iphonesimulator             -destination 'platform=iOS Simulator,name=iPhone 15,OS=17.5'             clean test | xcpretty\n\n      - name: Build .ipa with gym (fastlane)\n        env:\n          MATCH_KEYCHAIN_NAME: build.keychain\n        run: |\n          fastlane gym             --scheme \"App\"             --configuration Release             --export_method app-store\n\n      - name: Upload to TestFlight (fastlane pilot)\n        env:\n          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APPSTORE_KEY_ID }}\n          APP_STORE_CONNECT_API_KEY_ISSUER_ID: ${{ secrets.APPSTORE_ISSUER_ID }}\n          APP_STORE_CONNECT_API_KEY_CONTENT: ${{ secrets.APPSTORE_KEY_CONTENT }}\n        run: |\n          fastlane pilot upload             --api_key_path &lt;(cat &lt;&lt;EOF\n          {\n            \"key_id\": \"${APP_STORE_CONNECT_API_KEY_ID}\",\n            \"issuer_id\": \"${APP_STORE_CONNECT_API_KEY_ISSUER_ID}\",\n            \"key\": \"${APP_STORE_CONNECT_API_KEY_CONTENT}\",\n            \"in_house\": false\n          }\n          EOF\n          )             --skip_waiting_for_build_processing true\n</code></pre> Checklist: CI/CD en Apps Nativas <p>En apps m\u00f3viles nativas (Android/iOS) el uso de CI/CD no solo asegura compilaci\u00f3n y tests, sino que a\u00f1ade valor espec\u00edfico por la forma en que se distribuyen:</p> <p>- Compilaci\u00f3n con SDKs oficiales (Android SDK, Xcode).</p> <p>- Firma autom\u00e1tica de builds (keystore en Android, certificados y perfiles en iOS).</p> <p>- Generaci\u00f3n de artefactos v\u00e1lidos para tiendas (AAB/APK en Google Play, IPA en App Store).</p> <p>- Distribuci\u00f3n automatizada a testers (Firebase App Distribution, TestFlight).</p> <p>- Publicaci\u00f3n directa en tiendas (Google Play tracks, App Store Connect).</p> <p>- Reducci\u00f3n de errores manuales en procesos de empaquetado y despliegue.</p> <p>Con CI/CD en apps nativas, se resuelve el mayor cuello de botella: preparar, firmar y distribuir builds de forma segura y repetible.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/workflows_mobile_ci/#opciones-avanzadas-en-cicd-para-apps-nativas","title":"Opciones avanzadas en CI/CD para apps nativas","text":"<p>Cach\u00e9 de dependencias m\u00e1s agresivo </p> <ul> <li>Implica cachear no solo Gradle wrapper y dependencias, sino tambi\u00e9n el Android build cache.  </li> <li>Ventaja: builds mucho m\u00e1s r\u00e1pidas.  </li> <li>Riesgo: si el cache se corrompe o queda desincronizado, puede ser necesario limpiar manualmente.  </li> </ul> <p>Cache de Dependencias</p> <p>Matrices de versiones</p> <ul> <li>Implica definir un job que se ejecute en varias combinaciones de JDK, API level de Android, o incluso distintos sistemas operativos.  </li> <li>Ventaja: pruebas de compatibilidad amplia sin duplicar c\u00f3digo del workflow.  </li> <li>Riesgo: tiempos de ejecuci\u00f3n m\u00e1s largos, porque cada combinaci\u00f3n lanza un job independiente.  </li> </ul> <p>Matrices de Versiones</p> <p>Firma avanzada</p> <ul> <li>Automatizar el uso de keystore (Android) y certificados/provisioning (iOS) desde GitHub Secrets o Environments.  </li> <li>Ventaja: builds firmadas autom\u00e1ticamente listas para subir a Play/App Store.  </li> <li>Riesgo: mayor complejidad en la gesti\u00f3n de secretos; se deben proteger bien.</li> </ul> <p>Firma Avanzada</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/workflows_mobile_ci_commented/","title":"Workflows CI/CD para Apps Nativas \u2014 Versiones comentadas","text":""},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/workflows_mobile_ci_commented/#android-kotlin-gradle-build-tests-firebase-app-distribution-y-google-play-tracks","title":"Android (Kotlin, Gradle) \u2014 build, tests, Firebase App Distribution y Google Play (tracks)","text":"<p>Guarda este contenido como: <code>.github/workflows/android-ci.yml</code></p> <pre><code># =========================\n#  Android CI \u2014 Workflow\n#  Build, tests, distribuci\u00f3n a testers (Firebase) y publicaci\u00f3n en Google Play\n# =========================\n\nname: Android CI  # Nombre visible del workflow en la UI de GitHub\n\non:\n  push:\n    branches: [ main ]   # Ejecuta en pushes a la rama main; ajusta si usas \"develop\" u otras\n  pull_request:          # Ejecuta tambi\u00e9n en PRs para validar cambios antes de fusionarlos\n\njobs:\n  # -------------------------\n  # 1) Compilaci\u00f3n y tests unitarios (r\u00e1pidos, sin emulador)\n  # -------------------------\n  build-and-unit-tests:\n    runs-on: ubuntu-latest             # Runner Linux (r\u00e1pido y econ\u00f3mico); suficiente para unit tests\n    permissions:\n      contents: read                   # Permiso m\u00ednimo necesario para hacer checkout del c\u00f3digo\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4      # Descarga el repo en el workspace del runner\n\n      - name: Set up Java 17\n        uses: actions/setup-java@v4\n        with:\n          distribution: temurin        # JDK Temurin (Adoptium), estable y recomendado\n          java-version: 17             # JDK versi\u00f3n 17 (frecuente en Android/Gradle actuales)\n\n      - name: Setup Gradle\n        uses: gradle/gradle-build-action@v3   # Configura Gradle y activa cach\u00e9 de dependencias autom\u00e1ticamente\n\n      - name: Setup Android SDK\n        uses: android-actions/setup-android@v3  # Instala herramientas del Android SDK seg\u00fan tu build\n        # Si necesitas paquetes/SDK espec\u00edficos, puedes a\u00f1adirlos v\u00eda 'packages:' (ver docs de la action)\n\n      - name: Build (assemble + unit tests)\n        run: ./gradlew clean assembleDebug testDebugUnitTest --stacktrace\n        # 'assembleDebug' genera el APK debug; 'testDebugUnitTest' ejecuta tests unitarios (JVM)\n        # '--stacktrace' facilita el diagn\u00f3stico al fallar la build\n\n  # -------------------------\n  # 2) Tests instrumentados (UI) en emulador Android\n  #    Nota: macOS suele ser m\u00e1s estable para emuladores x86_64\n  # -------------------------\n  android-instrumented-tests:\n    runs-on: macos-latest              # Ejecuta en macOS para mayor estabilidad del emulador\n    needs: build-and-unit-tests        # Solo corre si el job anterior pas\u00f3 correctamente\n\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-java@v4\n        with:\n          distribution: temurin\n          java-version: 17\n      - name: Setup Gradle\n        uses: gradle/gradle-build-action@v3\n\n      - name: Run UI tests on emulator\n        uses: reactivecircus/android-emulator-runner@v2\n        with:\n          api-level: 34                # Selecciona la API a probar (puedes usar matrices si quieres varias)\n          arch: x86_64                 # Arquitectura del emulador\n          profile: pixel_6             # Perfil de dispositivo (opcional, ayuda a reproducibilidad)\n          script: ./gradlew connectedDebugAndroidTest\n          # 'connectedDebugAndroidTest' lanza tests instrumentados contra el emulador iniciado por la action\n\n  # -------------------------\n  # 3) Distribuci\u00f3n a testers con Firebase App Distribution (rama main)\n  # -------------------------\n  distribute-firebase:\n    runs-on: ubuntu-latest\n    needs: build-and-unit-tests        # Requiere que la compilaci\u00f3n y tests unitarios se hayan completado\n    if: github.ref == 'refs/heads/main'  # Solo en pushes a main (evita distribuir builds de PRs/ramas)\n\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-java@v4\n        with:\n          distribution: temurin\n          java-version: 17\n      - uses: gradle/gradle-build-action@v3\n\n      - name: Build release\n        run: ./gradlew clean bundleRelease\n        # Genera un Android App Bundle (AAB) de release; ideal para testers y para Play\n\n      - name: Upload to Firebase App Distribution\n        env:\n          FIREBASE_TOKEN: ${{ secrets.FIREBASE_TOKEN }}\n          # Alternativa: usar credenciales de servicio JSON y configurar el plugin Gradle de App Distribution\n        run: |\n          ./gradlew appDistributionUploadRelease             -PfirebaseServiceCredentialsFile=$GITHUB_WORKSPACE/fastlane/firebase-service-account.json             -PfirebaseTesters=\"${{ vars.FIREBASE_TESTERS }}\"             -PfirebaseReleaseNotes=\"CI upload from $GITHUB_SHA\"\n        # Notas:\n        # - Define testers (emails/grupos) en 'FIREBASE_TESTERS' o en build.gradle seg\u00fan prefieras.\n        # - 'FIREBASE_TOKEN' o credenciales de servicio son necesarios para autenticar.\n\n  # -------------------------\n  # 4) Publicaci\u00f3n en Google Play (track internal) al crear un tag 'v*'\n  #    Usamos Gradle Play Publisher (GPP) con cuenta de servicio JSON\n  # -------------------------\n  publish-play-internal:\n    runs-on: ubuntu-latest\n    needs: build-and-unit-tests            # Asegura que la build pas\u00f3 antes de publicar\n    if: startsWith(github.ref, 'refs/tags/v')  # Solo al publicar una etiqueta de release (ej: v1.2.3)\n\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-java@v4\n        with:\n          distribution: temurin\n          java-version: 17\n      - uses: gradle/gradle-build-action@v3\n\n      - name: Build AAB\n        run: ./gradlew clean bundleRelease\n        # Vuelve a generar el AAB de release, asegurando artefacto fresco para Play\n\n      - name: Publish to Play (internal track) via GPP\n        env:\n          PLAY_SERVICE_ACCOUNT_JSON: ${{ secrets.PLAY_SERVICE_ACCOUNT_JSON }}  # Contenido JSON (base64 o texto)\n        run: |\n          # Escribimos el JSON de la cuenta de servicio a un fichero para usarlo con GPP\n          echo '${{ secrets.PLAY_SERVICE_ACCOUNT_JSON }}' &gt; play-sa.json\n          # Ejecutamos publicaci\u00f3n con track 'internal' (puedes usar 'alpha', 'beta', 'production')\n          ./gradlew publishRelease             -Pandroid.injected.signing.store.file=$GITHUB_WORKSPACE/keystore.jks             -Pandroid.injected.signing.store.password=${{ secrets.SIGNING_STORE_PASSWORD }}             -Pandroid.injected.signing.key.alias=${{ secrets.SIGNING_KEY_ALIAS }}             -Pandroid.injected.signing.key.password=${{ secrets.SIGNING_KEY_PASSWORD }}             -Pplay.serviceAccountCredentials=$GITHUB_WORKSPACE/play-sa.json             -Pplay.track=internal\n        # Requisitos:\n        # - Keystore y passwords en Secrets (SIGNING_*).\n        # - Cuenta de servicio con permisos en Play Console (rol 'Release Manager' o similar).\n        # - El plugin GPP configurado en build.gradle (applicationId, etc.).\n</code></pre>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/workflows_mobile_ci_commented/#ios-swift-o-kotlin-multiplatform-ios-build-unit-tests-testflight","title":"iOS (Swift o Kotlin Multiplatform iOS) \u2014 build + unit tests + TestFlight","text":"<p>Guarda este contenido como: <code>.github/workflows/ios-ci.yml</code></p> <pre><code># =========================\n#  iOS CI \u2014 Workflow\n#  Build, tests en simulador y subida a TestFlight (App Store Connect)\n# =========================\n\nname: iOS CI  # Nombre del workflow\n\non:\n  push:\n    branches: [ main ]        # Ejecutar en pushes a main\n  pull_request:               # Validar tambi\u00e9n en PRs\n  workflow_dispatch:          # Permite lanzarlo manualmente desde la UI de Actions\n\njobs:\n  build-test-upload:\n    runs-on: macos-latest     # Requisito para Xcode y simuladores iOS\n    timeout-minutes: 60       # Evita jobs colgados; ajusta seg\u00fan tiempos de tu proyecto\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4   # Descarga el repo\n\n      - name: Show Xcode version\n        run: xcodebuild -version    # \u00datil para logs y depuraci\u00f3n (muestra versi\u00f3n de Xcode usada)\n\n      - name: Set up Ruby &amp; Fastlane\n        run: |\n          # Fastlane es la herramienta de facto para automatizar iOS (build, firma y distribuci\u00f3n)\n          gem install bundler:2.5.10\n          gem install fastlane --no-document\n\n      - name: Build &amp; unit tests (Simulator)\n        run: |\n          # Compila y ejecuta tests en simulador (no requiere firma)\n          # Ajusta el esquema (\"App\") y el destino (dispositivo/OS) a tu proyecto\n          xcodebuild             -scheme \"App\"             -sdk iphonesimulator             -destination 'platform=iOS Simulator,name=iPhone 15,OS=17.5'             clean test | xcpretty\n        # Consejo: usa 'xcpretty' para mejorar la legibilidad del log\n\n      - name: Build .ipa with gym (fastlane)\n        env:\n          MATCH_KEYCHAIN_NAME: build.keychain   # (Opcional) si usas match / keychains custom\n        run: |\n          # 'gym' genera el .ipa listo para distribuci\u00f3n (requiere firma)\n          # --export_method app-store: orientado a TestFlight / App Store\n          fastlane gym             --scheme \"App\"             --configuration Release             --export_method app-store\n        # Requisitos de firma:\n        # - Certificados y perfiles de aprovisionamiento v\u00e1lidos.\n        # - Puedes gestionarlos con fastlane match o subirlos como Secrets y configurarlos en el runner.\n\n      - name: Upload to TestFlight (fastlane pilot)\n        env:\n          # API Key de App Store Connect (recomendado frente a Apple ID + 2FA)\n          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APPSTORE_KEY_ID }}\n          APP_STORE_CONNECT_API_KEY_ISSUER_ID: ${{ secrets.APPSTORE_ISSUER_ID }}\n          APP_STORE_CONNECT_API_KEY_CONTENT: ${{ secrets.APPSTORE_KEY_CONTENT }}  # Contenido del .p8\n        run: |\n          # Construimos el JSON de la API Key en caliente y lo pasamos a fastlane pilot\n          fastlane pilot upload             --api_key_path &lt;(cat &lt;&lt;EOF\n          {\n            \"key_id\": \"${APP_STORE_CONNECT_API_KEY_ID}\",\n            \"issuer_id\": \"${APP_STORE_CONNECT_API_KEY_ISSUER_ID}\",\n            \"key\": \"${APP_STORE_CONNECT_API_KEY_CONTENT}\",\n            \"in_house\": false\n          }\n          EOF\n          )             --skip_waiting_for_build_processing true\n        # Notas:\n        # - 'skip_waiting_for_build_processing' devuelve el control antes de que Apple finalice el procesado.\n        # - Aseg\u00farate de que los metadatos de la app est\u00e1n configurados en App Store Connect para TestFlight.\n</code></pre>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_fases/","title":"Fases de dise\u00f1o","text":""},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_fases/#fases","title":"Fases","text":""},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_fases/#analisis","title":"An\u00e1lisis","text":""},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_fases/#definicion","title":"Definici\u00f3n","text":""},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_fases/#diseno","title":"Dise\u00f1o","text":""},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_fases/#desarrollo","title":"Desarrollo","text":""},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_fases/#publicacion","title":"Publicaci\u00f3n","text":""},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_fases/#proceso","title":"Proceso","text":""},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_fases/#_1","title":"Fases de dise\u00f1o","text":""},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_fases/#ejemplos","title":"Ejemplos","text":""},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_fases/#carrefur","title":"Carrefur","text":""},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_fases/#mercadona","title":"Mercadona","text":""},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_fases/#guaguas","title":"Guaguas","text":""},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_fases/#placas-solares","title":"Placas solares","text":""},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_fases/#carga-wallbox","title":"Carga Wallbox","text":""},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_fases/#android","title":"Android","text":""},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_fases/#vinos","title":"Vinos","text":""},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_fases/#yuka","title":"Yuka","text":""},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_fases/#facebook","title":"Facebook","text":""},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_fases/#whatsapp","title":"WhatsApp","text":""},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_fases/#path","title":"Path","text":""},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_fases/#resoluciones","title":"Resoluciones","text":""},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_fases/#caracteristicas","title":"Caracter\u00edsticas","text":""},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_fases/#design-thinking-process-model","title":"Design Thinking process model","text":""},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_interfaces/","title":"Dise\u00f1o de Interfaces para Aplicaciones M\u00f3viles Nativas","text":""},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_interfaces/#introduccion","title":"Introducci\u00f3n","text":"<p>El dise\u00f1o de interfaces en aplicaciones m\u00f3viles nativas es un elemento esencial para garantizar la usabilidad, accesibilidad y consistencia visual de una aplicaci\u00f3n. A diferencia de las aplicaciones web o de escritorio, las apps m\u00f3viles nativas deben adaptarse a pantallas peque\u00f1as, entornos de movilidad y formas de interacci\u00f3n t\u00e1ctil.</p> <p>Los objetivos principales del dise\u00f1o nativo son: - Maximizar la claridad visual. - Reducir la carga cognitiva del usuario. - Integrar la interfaz con el sistema operativo para ofrecer una experiencia coherente.</p>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_interfaces/#principios-de-diseno-movil-nativo","title":"Principios de dise\u00f1o m\u00f3vil nativo","text":"<p>Los sistemas operativos m\u00f3viles proporcionan gu\u00edas oficiales de dise\u00f1o que recogen los principios fundamentales de la experiencia nativa.</p>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_interfaces/#principios-generales","title":"Principios generales:","text":"<ul> <li>Claridad: el contenido debe ser f\u00e1cil de leer y comprender.</li> <li>Jerarqu\u00eda visual: organizar la informaci\u00f3n de forma que los elementos m\u00e1s importantes sean m\u00e1s visibles.</li> <li>Simplicidad: mostrar solo lo necesario; eliminar elementos que no aporten valor.</li> <li>Feedback inmediato: el sistema debe responder de manera visible o t\u00e1ctil a las acciones del usuario.</li> <li>Accesibilidad: todos los usuarios deben poder interactuar con la aplicaci\u00f3n, independientemente de sus capacidades.</li> <li>Consistencia: mantener coherencia en iconograf\u00eda, tipograf\u00eda, colores y disposici\u00f3n.</li> </ul> <p>Etapas</p>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_interfaces/#guias-de-diseno-oficiales","title":"Gu\u00edas de dise\u00f1o oficiales","text":""},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_interfaces/#ios-apple-human-interface-guidelines-hig","title":"iOS \u2013 Apple Human Interface Guidelines (HIG)","text":"<p>Principios clave seg\u00fan Apple: - Claridad, deferencia y profundidad. - Uso de componentes nativos como Navigation Bars, Tab Bars y Buttons. - Espaciado t\u00e1ctil m\u00ednimo de 44x44 pt por elemento interactivo. - Transiciones suaves y animaciones naturales. - Adaptaci\u00f3n a distintos dispositivos (iPhone, iPad, Apple Watch).</p> <p>Recurso oficial: Apple Human Interface Guidelines</p>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_interfaces/#android-material-design","title":"Android \u2013 Material Design","text":"<p>Principios clave de Material Design: - Material como met\u00e1fora visual: uso de profundidad, sombras y capas. - Movimiento con prop\u00f3sito: animaciones que refuercen las relaciones entre pantallas. - Adaptabilidad: dise\u00f1os que funcionen en m\u00faltiples densidades y tama\u00f1os de pantalla. - Componentes comunes: App Bar, Bottom Navigation, Floating Action Button, Cards, etc.</p> <p>Recurso oficial: Material Design 3</p>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_interfaces/#diferencias-entre-diseno-nativo-e-hibrido","title":"Diferencias entre dise\u00f1o nativo e h\u00edbrido","text":"Aspecto Apps nativas Apps h\u00edbridas Lenguaje de dise\u00f1o Siguen las gu\u00edas HIG o Material Design. Usan un estilo gen\u00e9rico o multiplataforma. Componentes UI Controles nativos del sistema operativo. Renderizados en WebView o simulados. Experiencia de usuario M\u00e1s fluida y coherente. Puede ser menos natural si no se adapta bien. Consistencia visual Alta, adaptada a cada SO. Unificada entre plataformas. Rendimiento gr\u00e1fico M\u00e1ximo aprovechamiento del hardware. Limitado por el motor h\u00edbrido. <p>Conclusi\u00f3n: el dise\u00f1o nativo ofrece una experiencia m\u00e1s integrada y coherente, mientras que el h\u00edbrido busca la uniformidad entre plataformas.</p>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_interfaces/#consideraciones-especificas-del-diseno-nativo","title":"Consideraciones espec\u00edficas del dise\u00f1o nativo","text":""},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_interfaces/#interaccion-tactil-y-gestos","title":"Interacci\u00f3n t\u00e1ctil y gestos","text":"<ul> <li>Tama\u00f1os de botones adecuados (m\u00ednimo 44px de alto).</li> <li>Gestos est\u00e1ndar: tap, swipe, pinch, long press.</li> <li>Evitar \u00e1reas peque\u00f1as o elementos demasiado juntos.</li> </ul>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_interfaces/#navegacion-y-estructura","title":"Navegaci\u00f3n y estructura","text":"<ul> <li>Navegaci\u00f3n jer\u00e1rquica clara.</li> <li>Uso adecuado de Back, Tabs y Stacks.</li> <li>Mantener una navegaci\u00f3n consistente en todas las pantallas.</li> </ul>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_interfaces/#animaciones-y-transiciones","title":"Animaciones y transiciones","text":"<ul> <li>Utilizar animaciones funcionales (no decorativas).</li> <li>Mantener la fluidez (60 FPS ideal).</li> <li>Evitar animaciones largas o intrusivas.</li> </ul>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_interfaces/#adaptacion-de-pantallas","title":"Adaptaci\u00f3n de pantallas","text":"<ul> <li>Dise\u00f1ar layouts flexibles que se ajusten a orientaciones y tama\u00f1os variados.</li> <li>Usar rejillas, m\u00e1rgenes adaptativos y auto-layouts.</li> </ul>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_interfaces/#accesibilidad","title":"Accesibilidad","text":"<ul> <li>Alto contraste de color.</li> <li>Etiquetas de accesibilidad (aria-labels).</li> <li>Compatibilidad con VoiceOver y TalkBack.</li> <li>Tama\u00f1os de fuente escalables.</li> </ul>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_interfaces/#privacidad-y-permisos","title":"Privacidad y permisos","text":"<ul> <li>Informar al usuario sobre los motivos de cada permiso.</li> <li>Mostrar solicitudes solo cuando sean necesarias.</li> <li>Fomentar la confianza mediante transparencia.</li> </ul>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_interfaces/#rendimiento","title":"Rendimiento","text":"<ul> <li>Cargas diferidas (lazy loading).</li> <li>Minimizar llamadas de red y animaciones complejas.</li> <li>Evitar bloqueos de la interfaz.</li> </ul>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_interfaces/#patrones-y-componentes-comunes","title":"Patrones y componentes comunes","text":"<ul> <li>Cards: agrupan informaci\u00f3n de forma visualmente clara.  </li> <li>Lists: permiten desplazamiento vertical fluido.  </li> <li>Dialogs y modales: deben usarse solo para acciones cr\u00edticas.  </li> <li>Floating Action Button: acci\u00f3n principal en Android.  </li> <li>Tab Bars / Bottom Navigation: navegaci\u00f3n simple entre secciones.</li> </ul>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_interfaces/#proceso-de-diseno-aplicado","title":"Proceso de dise\u00f1o aplicado","text":"<ol> <li>Investigaci\u00f3n: an\u00e1lisis del usuario y de sus necesidades.  </li> <li>Prototipado: bocetos de baja fidelidad y wireframes.  </li> <li>Dise\u00f1o visual: aplicaci\u00f3n de gu\u00edas de estilo y componentes.  </li> <li>Validaci\u00f3n: pruebas de usabilidad y correcci\u00f3n de errores.  </li> <li>Implementaci\u00f3n: entrega del dise\u00f1o a los desarrolladores.  </li> <li>Iteraci\u00f3n: mejoras continuas tras feedback del usuario.</li> </ol>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_interfaces/#tendencias-y-futuro-del-diseno-movil","title":"Tendencias y futuro del dise\u00f1o m\u00f3vil","text":"<ul> <li>Interfaces adaptativas: que se ajustan al contexto del usuario.  </li> <li>Modo oscuro y temas din\u00e1micos.  </li> <li>Dise\u00f1os para pantallas plegables. </li> <li>Integraci\u00f3n con wearables y asistentes de voz. </li> </ul>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_interfaces/#evolucion-y-nuevas-direcciones-del-diseno-movil","title":"Evoluci\u00f3n y nuevas direcciones del dise\u00f1o m\u00f3vil","text":"<p>El dise\u00f1o de interfaces m\u00f3viles nativas ha alcanzado un alto grado de madurez. Muchos de los aspectos que hace pocos a\u00f1os se consideraban tendencias \u2014como el modo oscuro, las interfaces adaptativas o el dise\u00f1o responsivo\u2014 son hoy est\u00e1ndares consolidados en iOS y Android.  </p> <p>Sin embargo, el dise\u00f1o m\u00f3vil sigue evolucionando en varias direcciones que apuntan al futuro inmediato:</p>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_interfaces/#interfaces-contextuales-context-aware-ui","title":"Interfaces contextuales (Context-Aware UI)","text":"<p>Las interfaces comienzan a adaptarse din\u00e1micamente al entorno f\u00edsico o al comportamiento del usuario: - Ajuste de brillo, contraste o disposici\u00f3n seg\u00fan la luz ambiental. - Cambios en la presentaci\u00f3n si el usuario est\u00e1 en movimiento, conduciendo o con conectividad limitada. - Priorizaci\u00f3n de contenido relevante en funci\u00f3n del contexto.  </p>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_interfaces/#diseno-para-dispositivos-plegables-y-flexibles","title":"Dise\u00f1o para dispositivos plegables y flexibles","text":"<p>Los nuevos formatos de pantalla introducen retos en continuidad de la interfaz y escalabilidad visual: - Adaptaci\u00f3n fluida al cambiar entre modo compacto y expandido. - Reorganizaci\u00f3n de la jerarqu\u00eda visual al plegar o desplegar el dispositivo.  </p>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_interfaces/#diseno-multimodal","title":"Dise\u00f1o multimodal","text":"<p>El futuro del dise\u00f1o m\u00f3vil pasa por la integraci\u00f3n de diferentes modos de interacci\u00f3n: - Comandos de voz con asistentes virtuales (Siri, Google Assistant). - Gestos, reconocimiento facial o detecci\u00f3n de mirada. - Combinaci\u00f3n de texto, voz y movimiento para ofrecer experiencias m\u00e1s naturales.  </p>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_interfaces/#personalizacion-basada-en-ia","title":"Personalizaci\u00f3n basada en IA","text":"<p>Las interfaces comienzan a aprovechar la inteligencia artificial para adaptarse a los patrones de uso del usuario: - Ajuste autom\u00e1tico de la disposici\u00f3n y funciones m\u00e1s utilizadas. - Recomendaciones de contenido o accesos directos contextuales. - Ajuste de colores o tipograf\u00eda en funci\u00f3n de la preferencia o fatiga visual detectada.  </p>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_interfaces/#experiencias-conectadas-y-ecosistema-unificado","title":"Experiencias conectadas y ecosistema unificado","text":"<p>Las apps ya no se dise\u00f1an para un solo dispositivo, sino como parte de un ecosistema coherente: - Continuidad entre tel\u00e9fono, reloj, coche y hogar inteligente. - Sincronizaci\u00f3n fluida de estados y sesiones. - Dise\u00f1o coherente entre pantallas de distinto tama\u00f1o y uso.  </p> <p>En s\u00edntesis: el dise\u00f1o m\u00f3vil nativo evoluciona hacia interfaces m\u00e1s adaptativas, inteligentes y contextuales, capaces de anticipar las necesidades del usuario y ofrecer experiencias unificadas en todo su ecosistema digital.</p>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/diseno_interfaces/#conclusiones","title":"Conclusiones","text":"<ul> <li>Las aplicaciones nativas deben ofrecer una experiencia coherente, fluida y contextual.  </li> <li>Los principios de claridad, consistencia, accesibilidad y feedback son universales.  </li> <li>Conocer las gu\u00edas oficiales (HIG y Material) es imprescindible para un dise\u00f1o de calidad.  </li> </ul> <p>Android e IOS</p>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/interfaces_tecnico/","title":"Dise\u00f1o de interfaces a nivel t\u00e9cnico: frameworks y librer\u00edas en Android e iOS","text":"<p>Adem\u00e1s de los principios conceptuales de dise\u00f1o, es fundamental comprender c\u00f3mo se materializan t\u00e9cnicamente las interfaces en cada plataforma nativa. Tanto Android como iOS han evolucionado desde modelos imperativos hacia paradigmas declarativos m\u00e1s modernos, centrados en la sincronizaci\u00f3n autom\u00e1tica entre el estado y la interfaz.</p>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/interfaces_tecnico/#android-jetpack-compose","title":"Android: Jetpack Compose","text":"<p>Jetpack Compose es el framework moderno de Android para la creaci\u00f3n de interfaces declarativas. Reemplaza al sistema tradicional basado en XML, permitiendo definir la UI con c\u00f3digo Kotlin y funciones reactivas.</p>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/interfaces_tecnico/#principios-tecnicos","title":"Principios t\u00e9cnicos","text":"<ul> <li>Las interfaces se definen con funciones anotadas con <code>@Composable</code>.  </li> <li>La UI se actualiza autom\u00e1ticamente cuando cambian los estados observables.  </li> <li>Utiliza un modelo de recomposici\u00f3n: solo se vuelven a renderizar los elementos afectados por el cambio.</li> </ul> <pre><code>@Composable\nfun CounterScreen() {\n    var count by remember { mutableStateOf(0) }\n    Column(horizontalAlignment = Alignment.CenterHorizontally) {\n        Text(\"Contador: $count\")\n        Button(onClick = { count++ }) {\n            Text(\"Incrementar\")\n        }\n    }\n}\n</code></pre>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/interfaces_tecnico/#arquitectura-y-patrones","title":"Arquitectura y patrones","text":"<ul> <li>Patrones comunes: MVVM (Model\u2013View\u2013ViewModel) y Unidirectional Data Flow.  </li> <li>Integraci\u00f3n nativa con <code>ViewModel</code> y <code>StateFlow</code> / <code>LiveData</code> para gesti\u00f3n del estado.  </li> <li>Composici\u00f3n modular de UI con componentes reutilizables (composables).</li> </ul>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/interfaces_tecnico/#librerias-y-herramientas-clave","title":"Librer\u00edas y herramientas clave","text":"<ul> <li>Material Design 3: componentes visuales oficiales (<code>Button</code>, <code>Card</code>, <code>NavigationBar</code>, etc.).  </li> <li>Accompanist: extensiones para Compose (im\u00e1genes, animaciones, paginaci\u00f3n, etc.).  </li> <li>Showkase: cat\u00e1logo visual de componentes UI para desarrollo colaborativo.  </li> <li>Voyager / Navigation Compose: navegaci\u00f3n declarativa simplificada.  </li> <li>Katalog: explorador visual de componentes, \u00fatil en proyectos grandes.  </li> <li>Interoperabilidad: permite integrar <code>Compose</code> con vistas XML cl\u00e1sicas mediante <code>ComposeView</code> o <code>AndroidView</code>.</li> </ul> <p>Recurso oficial: Jetpack Compose \u2013 Android Developers</p>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/interfaces_tecnico/#ios-uikit-y-swiftui","title":"iOS: UIKit y SwiftUI","text":"<p>En iOS existen dos principales enfoques para construir interfaces:</p>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/interfaces_tecnico/#1-uikit-modelo-tradicional","title":"1. UIKit (modelo tradicional)","text":"<ul> <li>Framework imperativo basado en clases <code>UIView</code> y <code>UIViewController</code>.  </li> <li>Las interfaces se definen en storyboards o mediante c\u00f3digo.  </li> <li>Se actualiza la UI manualmente en respuesta a eventos.  </li> <li>Patrones comunes: MVC, MVP, MVVM, VIPER, Coordinator.  </li> </ul>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/interfaces_tecnico/#2-swiftui-modelo-declarativo-moderno","title":"2. SwiftUI (modelo declarativo moderno)","text":"<p>Introducido por Apple en 2019, SwiftUI permite definir la interfaz como una funci\u00f3n del estado actual de la aplicaci\u00f3n, simplificando el desarrollo y mejorando la coherencia visual.</p> <pre><code>struct ContentView: View {\n    @State private var counter = 0\n\n    var body: some View {\n        VStack {\n            Text(\"Contador: \\(counter)\")\n            Button(\"Incrementar\") {\n                counter += 1\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/interfaces_tecnico/#arquitectura-y-patrones-en-swiftui","title":"Arquitectura y patrones en SwiftUI","text":"<ul> <li>Patr\u00f3n recomendado: MVVM (Model\u2013View\u2013ViewModel).  </li> <li><code>@State</code>, <code>@Published</code> y <code>@ObservableObject</code> gestionan el flujo de datos reactivo.  </li> <li>Integraci\u00f3n con <code>Combine</code> o <code>async/await</code> para sincronizar datos as\u00edncronos.  </li> <li>Tambi\u00e9n se utiliza la Clean Architecture adaptada a SwiftUI para proyectos grandes.  </li> </ul>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/interfaces_tecnico/#librerias-y-utilidades-relevantes","title":"Librer\u00edas y utilidades relevantes","text":"<ul> <li>SwiftUIX: ampl\u00eda los componentes est\u00e1ndar de SwiftUI.  </li> <li>The Composable Architecture (TCA): arquitectura modular basada en estados, acciones y efectos.  </li> <li>Lottie-iOS: animaciones vectoriales en formato JSON.  </li> <li>Charts / Swift Charts: creaci\u00f3n de gr\u00e1ficos nativos.  </li> <li>Interoperabilidad: se puede integrar UIKit y SwiftUI en la misma app (<code>UIViewRepresentable</code> y <code>UIHostingController</code>).</li> </ul> <p>\ud83d\udcd8 Recurso oficial: Apple Developer \u2013 SwiftUI</p>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/interfaces_tecnico/#comparativa-tecnica","title":"Comparativa t\u00e9cnica","text":"Aspecto Android (Jetpack Compose) iOS (SwiftUI) Paradigma UI Declarativo Declarativo Lenguaje Kotlin Swift Gesti\u00f3n del estado <code>State</code>, <code>MutableState</code>, <code>StateFlow</code>, <code>ViewModel</code> <code>@State</code>, <code>@Published</code>, <code>ObservableObject</code> Componentes nativos Composables de Material Design Vistas SwiftUI nativas Estilos y temas Material Theme, color din\u00e1mico, modo oscuro autom\u00e1tico Light/Dark mode, Dynamic Type, system accent colors Animaciones <code>animate*AsState</code>, <code>Transition</code>, <code>AnimatedVisibility</code> <code>.animation()</code>, <code>withAnimation</code>, transiciones impl\u00edcitas Arquitectura recomendada MVVM + Unidirectional Data Flow MVVM + Combine / Async Await Interoperabilidad Compatibilidad con vistas XML Compatibilidad con UIKit Librer\u00edas destacadas Accompanist, Showkase, Voyager, Katalog SwiftUIX, TCA, Lottie, Charts"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/interfaces_tecnico/#conclusion-tecnica","title":"Conclusi\u00f3n t\u00e9cnica","text":"<ul> <li>Tanto Jetpack Compose como SwiftUI consolidan la tendencia hacia el dise\u00f1o declarativo, centrado en el estado y en la reactividad.  </li> <li>Ambos frameworks integran los principios de Material Design y Human Interface Guidelines dentro de sus librer\u00edas nativas.  </li> <li>El conocimiento de sus componentes, patrones y librer\u00edas es esencial para dise\u00f1ar interfaces modernas, eficientes y coherentes con cada plataforma.</li> </ul>"},{"location":"Bloque2_Desarrollo_Apps/bases_datos/","title":"Bases de Datos","text":"<p>Contenido en construcci\u00f3n...</p>"},{"location":"Bloque2_Desarrollo_Apps/calidad_software/","title":"Calidad del Software","text":"<p>Contenido en construcci\u00f3n...</p>"},{"location":"Bloque2_Desarrollo_Apps/patrones_diseno/","title":"Patrones de Dise\u00f1o","text":"<p>Selecciona un subtema del men\u00fa lateral.</p>"},{"location":"Bloque2_Desarrollo_Apps/patrones_diseno/comportamiento/","title":"Patrones de comportamiento","text":"<p>Contenido en construcci\u00f3n...</p>"},{"location":"Bloque2_Desarrollo_Apps/patrones_diseno/principios_estructurales/","title":"Principios y patrones estructurales cl\u00e1sicos","text":"<p>Contenido en construcci\u00f3n...</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/IOS/","title":"Sistema Operativo IOS","text":""},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/IOS/#introduccion","title":"Introducci\u00f3n","text":"<p>Si Android representa diversidad y apertura, iOS simboliza integraci\u00f3n y consistencia. Apple present\u00f3 su sistema operativo en 2007 con el primer iPhone, y desde entonces ha evolucionado de ser un software sencillo para llamadas, mensajes y navegaci\u00f3n b\u00e1sica, a convertirse en el centro de un ecosistema global que incluye iPads, relojes, televisores y hasta gafas de realidad mixta.  </p> <p>La gran diferencia de iOS es que Apple controla tanto el hardware como el software, lo que asegura fluidez, seguridad y actualizaciones inmediatas en todos los dispositivos compatibles. Cada versi\u00f3n ha ido puliendo esa experiencia, incorporando funciones que muchas veces marcaron el rumbo de la industria m\u00f3vil.  </p> <p>A continuaci\u00f3n, un repaso narrativo por la historia de iOS, sus transformaciones y las novedades que fueron conquistando a millones de usuarios.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/IOS/#iphone-os-1-2007-la-revolucion-tactil","title":"iPhone OS 1 (2007): la revoluci\u00f3n t\u00e1ctil","text":"<p>Con el primer iPhone, Apple mostr\u00f3 un sistema operativo que romp\u00eda con todo lo anterior: pantalla multit\u00e1ctil, gestos intuitivos, navegador Safari, correo electr\u00f3nico y reproductor de m\u00fasica. No hab\u00eda tienda de aplicaciones ni personalizaci\u00f3n, pero fue suficiente para cambiar para siempre lo que entend\u00edamos por tel\u00e9fono.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/IOS/#iphone-os-2-2008-nace-la-app-store","title":"iPhone OS 2 (2008): nace la App Store","text":"<p>El gran salto lleg\u00f3 con la App Store, que permiti\u00f3 descargar aplicaciones de terceros de forma sencilla y segura. Esta innovaci\u00f3n no solo ampli\u00f3 el potencial del iPhone, sino que tambi\u00e9n cre\u00f3 una nueva industria: la de las apps m\u00f3viles, con millones de desarrolladores y emprendedores en todo el mundo.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/IOS/#iphone-os-3-2009-consolidacion","title":"iPhone OS 3 (2009): consolidaci\u00f3n","text":"<p>Apple escuch\u00f3 a los usuarios y a\u00f1adi\u00f3 funciones b\u00e1sicas que se echaban en falta: copiar y pegar, MMS, b\u00fasqueda Spotlight y tethering. Fue una versi\u00f3n que convirti\u00f3 al iPhone en un dispositivo m\u00e1s completo y funcional.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/IOS/#ios-4-2010-el-cambio-de-nombre","title":"iOS 4 (2010): el cambio de nombre","text":"<p>El sistema pas\u00f3 a llamarse oficialmente iOS. Introdujo la multitarea (limitada pero \u00fatil), carpetas para organizar aplicaciones y la app iBooks. Tambi\u00e9n debut\u00f3 FaceTime, acercando las videollamadas a un p\u00fablico masivo.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/IOS/#ios-5-2011-icloud-y-siri","title":"iOS 5 (2011): iCloud y Siri","text":"<p>Con iOS 5 lleg\u00f3 iCloud, que sincronizaba datos entre dispositivos Apple, y las notificaciones mejoradas. Pero la estrella fue Siri, el primer asistente de voz integrado en un smartphone, que marc\u00f3 el inicio de la interacci\u00f3n por voz en m\u00f3viles.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/IOS/#ios-6-2012-independencia-de-google","title":"iOS 6 (2012): independencia de Google","text":"<p>Fue una versi\u00f3n pol\u00e9mica por el lanzamiento de Apple Maps, que sustituy\u00f3 a Google Maps y gener\u00f3 cr\u00edticas por sus errores iniciales. Tambi\u00e9n introdujo Passbook (precursor de Wallet) y una mayor integraci\u00f3n de Siri. Pese a sus tropiezos, fue un paso hacia la autonom\u00eda de Apple.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/IOS/#ios-7-2013-rediseno-radical","title":"iOS 7 (2013): redise\u00f1o radical","text":"<p>Apple cambi\u00f3 por completo la est\u00e9tica con el flat design, abandonando los skeumorfismos que imitaban objetos reales. Introdujo el Centro de Control, AirDrop y multitarea mejorada. El cambio fue tan dr\u00e1stico que gener\u00f3 divisi\u00f3n, pero defini\u00f3 la imagen del iOS moderno.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/IOS/#ios-8-2014-mas-abierto-a-los-desarrolladores","title":"iOS 8 (2014): m\u00e1s abierto a los desarrolladores","text":"<p>Permiti\u00f3 extensiones, teclados de terceros y a\u00f1adi\u00f3 HealthKit, la primera gran apuesta por la salud digital. Tambi\u00e9n lleg\u00f3 Continuity, que permit\u00eda empezar una tarea en un dispositivo y continuarla en otro dentro del ecosistema Apple.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/IOS/#ios-9-2015-estabilidad-y-optimizacion","title":"iOS 9 (2015): estabilidad y optimizaci\u00f3n","text":"<p>Se enfoc\u00f3 en mejorar el rendimiento, sobre todo en dispositivos antiguos. Introdujo Split View y Picture in Picture en iPad, y un Siri m\u00e1s proactivo. No fue una versi\u00f3n espectacular en novedades, pero s\u00ed clave en eficiencia.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/IOS/#ios-10-2016-mensajes-y-hogar-conectado","title":"iOS 10 (2016): mensajes y hogar conectado","text":"<p>La app de Mensajes se transform\u00f3 con stickers y efectos. La pantalla de bloqueo y las notificaciones se volvieron m\u00e1s interactivas. Adem\u00e1s, apareci\u00f3 la app Casa (Home), que convert\u00eda el iPhone en un centro de control para la dom\u00f3tica.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/IOS/#ios-11-2017-el-ipad-se-potencia","title":"iOS 11 (2017): el iPad se potencia","text":"<p>Esta versi\u00f3n fue especialmente relevante para el iPad, con un nuevo Dock, multitarea mejorada y soporte para arrastrar y soltar. Tambi\u00e9n debut\u00f3 ARKit, abriendo las puertas a la realidad aumentada dentro del ecosistema Apple.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/IOS/#ios-12-2018-rendimiento-y-bienestar","title":"iOS 12 (2018): rendimiento y bienestar","text":"<p>Se centr\u00f3 en hacer que incluso los dispositivos antiguos funcionaran mejor. Introdujo Screen Time para medir y limitar el uso del m\u00f3vil, notificaciones agrupadas y Siri Shortcuts. Fue una actualizaci\u00f3n muy bien recibida por su estabilidad.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/IOS/#ios-13-2019-modo-oscuro-y-privacidad","title":"iOS 13 (2019): modo oscuro y privacidad","text":"<p>Lleg\u00f3 el esperado modo oscuro, junto con mejoras en Fotos, Mapas y Recordatorios. Apple reforz\u00f3 la privacidad con el Inicio de sesi\u00f3n con Apple, una alternativa segura frente a Facebook o Google.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/IOS/#ios-14-2020-widgets-en-la-pantalla-de-inicio","title":"iOS 14 (2020): widgets en la pantalla de inicio","text":"<p>Una de las actualizaciones m\u00e1s visibles: los widgets llegaron a la pantalla principal, junto con App Library para organizar apps autom\u00e1ticamente. Tambi\u00e9n se reforz\u00f3 la privacidad con avisos de c\u00e1mara y micr\u00f3fono en uso.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/IOS/#ios-15-2021-comunicacion-y-concentracion","title":"iOS 15 (2021): comunicaci\u00f3n y concentraci\u00f3n","text":"<p>Mejor\u00f3 FaceTime con SharePlay, a\u00f1adi\u00f3 el modo Concentraci\u00f3n (Focus) para gestionar notificaciones y reforz\u00f3 la privacidad con funciones como Private Relay en Safari. iOS se volvi\u00f3 m\u00e1s personal y adaptado a cada usuario.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/IOS/#ios-16-2022-personalizacion-de-la-pantalla-de-bloqueo","title":"iOS 16 (2022): personalizaci\u00f3n de la pantalla de bloqueo","text":"<p>Una de las actualizaciones m\u00e1s queridas por los usuarios, que permiti\u00f3 personalizar la pantalla de bloqueo con widgets, relojes y fondos din\u00e1micos. Tambi\u00e9n a\u00f1adi\u00f3 la posibilidad de editar o borrar mensajes en iMessage y nuevas capas de seguridad.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/IOS/#ios-17-2023-mas-humano-y-social","title":"iOS 17 (2023): m\u00e1s humano y social","text":"<p>Introdujo los Contact Posters, que personalizan c\u00f3mo nos ven los dem\u00e1s en llamadas, y los videomensajes en FaceTime. Tambi\u00e9n lleg\u00f3 la app Diario (Journal) para fomentar la escritura personal y el bienestar digital.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/IOS/#ios-18-2024-la-era-de-la-inteligencia-artificial","title":"iOS 18 (2024): la era de la inteligencia artificial","text":"<p>La versi\u00f3n m\u00e1s reciente, iOS 18, ha sido apodada la gran actualizaci\u00f3n de la IA. Apple present\u00f3 Apple Intelligence, un conjunto de funciones basadas en inteligencia artificial que potencian aplicaciones como Mensajes, Correo y Fotos. Tambi\u00e9n ampli\u00f3 la personalizaci\u00f3n de la interfaz y mejor\u00f3 la gesti\u00f3n de notificaciones. Es un punto de inflexi\u00f3n que marca el inicio de una etapa en la que la IA ser\u00e1 central en la experiencia iOS.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/IOS/#conclusion","title":"Conclusi\u00f3n","text":"<p>Desde aquel primer iPhone en 2007 hasta la integraci\u00f3n de inteligencia artificial en 2024, iOS ha sido sin\u00f3nimo de innovaci\u00f3n y consistencia. Cada versi\u00f3n no solo a\u00f1adi\u00f3 funciones, sino que redefini\u00f3 c\u00f3mo interactuamos con nuestros dispositivos.  </p> <p>Hoy, con iOS 18, Apple mantiene su apuesta clara: un ecosistema unificado, seguro y cada vez m\u00e1s inteligente, donde el software se adapta a la persona, y no al rev\u00e9s.  </p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/IOS/#resumen-de-versiones-de-ios","title":"\ud83c\udf4f Resumen de versiones de iOS","text":"Versi\u00f3n A\u00f1o Nombre oficial Principales novedades 1 2007 iPhone OS 1 Multitouch, apps b\u00e1sicas (Safari, Mail, iPod), sin App Store. 2 2008 iPhone OS 2 App Store, inicio del ecosistema de apps. 3 2009 iPhone OS 3 Copiar/pegar, MMS, Spotlight, tethering. 4 2010 iOS 4 Cambio de nombre a iOS, multitarea, FaceTime, carpetas. 5 2011 iOS 5 iCloud, Siri, nuevo sistema de notificaciones. 6 2012 iOS 6 Apple Maps, Passbook, integraci\u00f3n con Facebook. 7 2013 iOS 7 Redise\u00f1o flat, Centro de Control, AirDrop. 8 2014 iOS 8 Extensiones, teclados de terceros, HealthKit, Continuity. 9 2015 iOS 9 Estabilidad, Split View en iPad, Siri proactivo. 10 2016 iOS 10 Renovaci\u00f3n de Mensajes, pantalla de bloqueo interactiva, HomeKit. 11 2017 iOS 11 Dock y multitarea en iPad, ARKit, mejoras en arrastrar y soltar. 12 2018 iOS 12 Screen Time, notificaciones agrupadas, Shortcuts. 13 2019 iOS 13 Modo oscuro, Inicio de sesi\u00f3n con Apple, mejoras en Fotos. 14 2020 iOS 14 Widgets en pantalla de inicio, App Library, privacidad reforzada. 15 2021 iOS 15 SharePlay, Modo Concentraci\u00f3n, mejoras en FaceTime y privacidad. 16 2022 iOS 16 Pantalla de bloqueo personalizable, editar/borrar mensajes. 17 2023 iOS 17 Contact Posters, videomensajes FaceTime, app Diario. 18 2024 iOS 18 Apple Intelligence (IA), personalizaci\u00f3n avanzada, notificaciones inteligentes."},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/android/","title":"Sistema Operativo Android","text":""},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/android/#introduccion","title":"Introducci\u00f3n","text":"<p>Android es un sistema operativo basado en Linux, dise\u00f1ado inicialmente para tel\u00e9fonos inteligentes y actualmente presente en una gran variedad de dispositivos: relojes, televisores, coches y hasta electrodom\u00e9sticos. Su lanzamiento oficial en 2008 marc\u00f3 un antes y un despu\u00e9s en la industria m\u00f3vil, gracias a su car\u00e1cter abierto, la posibilidad de ser adoptado por m\u00faltiples fabricantes y el apoyo de Google con un ecosistema de aplicaciones en constante crecimiento. A lo largo de los a\u00f1os, Android ha pasado por numerosas versiones que han ido incorporando mejoras en dise\u00f1o, seguridad, rendimiento y experiencia de usuario. A continuaci\u00f3n, se presenta un recorrido por sus principales versiones.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/android/#los-primeros-pasos-android-10-y-11-20082009","title":"Los primeros pasos: Android 1.0 y 1.1 (2008\u20132009)","text":"<p>En 2008, el HTC Dream fue el primer dispositivo con Android 1.0. Ofrec\u00eda lo esencial: navegador, sincronizaci\u00f3n con servicios de Google, Android Market (precursor de Google Play) y soporte para apps de terceros. Unos meses m\u00e1s tarde, Android 1.1 trajo peque\u00f1os ajustes, como adjuntar archivos en mensajes o mantener la pantalla encendida en llamadas. No era revolucionario, pero ciment\u00f3 la base de lo que vendr\u00eda.</p> <p></p> <p></p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/android/#el-comienzo-de-los-postres-cupcake-y-donut-2009","title":"El comienzo de los postres: Cupcake y Donut (2009)","text":"<p>Cupcake (1.5) fue la primera gran actualizaci\u00f3n. Introdujo el teclado virtual, widgets en pantalla, sincronizaci\u00f3n autom\u00e1tica y la posibilidad de subir v\u00eddeos a YouTube. Era el inicio del Android que hoy reconocemos.  </p> <p>Con Donut (1.6), Android se volvi\u00f3 m\u00e1s vers\u00e1til: mejor\u00f3 la b\u00fasqueda por voz y texto, a\u00f1adi\u00f3 un motor multiling\u00fce de s\u00edntesis de voz y, lo m\u00e1s importante, soport\u00f3 diferentes resoluciones de pantalla, lo que abri\u00f3 la puerta a la gran diversidad de dispositivos Android.</p> <p></p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/android/#eclair-y-froyo-20092010-el-salto-de-calidad","title":"Eclair y Froyo (2009\u20132010): el salto de calidad","text":"<p>Eclair (2.0\u20132.1) dio un gran paso hacia la modernidad: fondos animados, soporte multitouch, mejoras en la c\u00e1mara y Google Maps con navegaci\u00f3n integrada. Por primera vez, Android se sinti\u00f3 como un sistema competitivo frente a iOS.  </p> <p>Con Froyo (2.2) llegaron las notificaciones push, la posibilidad de instalar apps en la tarjeta SD y soporte para Adobe Flash, lo que en ese momento fue un gran reclamo frente a la limitaci\u00f3n de iOS.</p> <p></p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/android/#gingerbread-y-honeycomb-20102011-expansion-y-experimentacion","title":"Gingerbread y Honeycomb (2010\u20132011): expansi\u00f3n y experimentaci\u00f3n","text":"<p>Gingerbread (2.3) puli\u00f3 la interfaz, hizo m\u00e1s r\u00e1pido el teclado y a\u00f1adi\u00f3 soporte para NFC, algo adelantado a su tiempo. Tambi\u00e9n mejor\u00f3 el rendimiento para juegos y multimedia. Fue muy popular en los primeros smartphones Android masivos.  </p> <p>En paralelo, Honeycomb (3.0) fue un experimento exclusivo para tabletas. Introdujo una interfaz renovada con barra de sistema inferior y multitarea mejorada. Aunque no tuvo mucho recorrido, sent\u00f3 las bases para unificar m\u00f3viles y tablets m\u00e1s adelante.</p> <p></p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/android/#ice-cream-sandwich-y-jelly-bean-20112013-unificacion-y-fluidez","title":"Ice Cream Sandwich y Jelly Bean (2011\u20132013): unificaci\u00f3n y fluidez","text":"<p>Ice Cream Sandwich (4.0) unific\u00f3 la experiencia de m\u00f3viles y tablets, estren\u00f3 la tipograf\u00eda Roboto, el desbloqueo facial y un navegador con pesta\u00f1as al estilo de Chrome. Fue el inicio de un dise\u00f1o m\u00e1s coherente.  </p> <p>Con Jelly Bean (4.1\u20134.3) lleg\u00f3 el proyecto Butter, que mejor\u00f3 la fluidez de la interfaz. Tambi\u00e9n introdujo Google Now, notificaciones expandibles y dictado por voz sin conexi\u00f3n. Android empezaba a sentirse m\u00e1s inteligente y \u00e1gil.</p> <p></p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/android/#kitkat-y-lollipop-20132015-el-diseno-como-protagonista","title":"KitKat y Lollipop (2013\u20132015): el dise\u00f1o como protagonista","text":"<p>KitKat (4.4) moderniz\u00f3 la est\u00e9tica con transparencias y modo inmersivo, adem\u00e1s de optimizar el sistema para dispositivos de gama baja. Esto permiti\u00f3 llevar Android a millones de usuarios en mercados emergentes.  </p> <p>Lollipop (5.0\u20135.1) dio un giro visual con Material Design, lleno de colores y animaciones. Tambi\u00e9n incorpor\u00f3 soporte para procesadores de 64 bits, una nueva gesti\u00f3n de notificaciones y mejoras en la bater\u00eda. Fue un antes y un despu\u00e9s en la identidad visual de Android.</p> <p></p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/android/#marshmallow-y-nougat-20152016-seguridad-y-multitarea","title":"Marshmallow y Nougat (2015\u20132016): seguridad y multitarea","text":"<p>Marshmallow (6.0) trajo una de las funciones m\u00e1s esperadas: el gestor de permisos por aplicaci\u00f3n. Tambi\u00e9n a\u00f1adi\u00f3 soporte para huellas digitales y Android Pay. Adem\u00e1s, introdujo el modo Doze, que mejor\u00f3 notablemente el ahorro de bater\u00eda.  </p> <p>Nougat (7.0\u20137.1) apost\u00f3 por la productividad con la pantalla dividida y la optimizaci\u00f3n de recursos. Tambi\u00e9n a\u00f1adi\u00f3 soporte para Vulkan API y compatibilidad con Java 8. El sistema se volvi\u00f3 m\u00e1s maduro y flexible.</p> <p></p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/android/#oreo-y-pie-20172018-inteligencia-y-bienestar-digital","title":"Oreo y Pie (2017\u20132018): inteligencia y bienestar digital","text":"<p>Oreo (8.0\u20138.1) trajo Picture in Picture (PiP), iconos adaptativos y un nuevo sistema de notificaciones. Con Project Treble, se facilit\u00f3 la actualizaci\u00f3n de dispositivos, uno de los grandes problemas hist\u00f3ricos de Android.  </p> <p>Pie (9.0) introdujo la navegaci\u00f3n por gestos, la bater\u00eda adaptativa y el sistema Digital Wellbeing, pensado para fomentar un uso m\u00e1s saludable del m\u00f3vil. Android ya no solo buscaba potencia, tambi\u00e9n bienestar.</p> <p></p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/android/#android-10-y-11-20192020-hacia-una-experiencia-mas-integrada","title":"Android 10 y 11 (2019\u20132020): hacia una experiencia m\u00e1s integrada","text":"<p>Android 10 apost\u00f3 por la privacidad, con permisos m\u00e1s detallados, y a\u00f1adi\u00f3 el modo oscuro a todo el sistema. Tambi\u00e9n fue pionero en compatibilidad con redes 5G y tel\u00e9fonos plegables.  </p> <p>Android 11 puli\u00f3 la experiencia con burbujas de chat, un centro de control para dispositivos inteligentes y permisos temporales para apps. Android empezaba a integrarse mejor con el hogar conectado.</p> <p></p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/android/#android-12-y-13-20212022-personalizacion-y-seguridad","title":"Android 12 y 13 (2021\u20132022): personalizaci\u00f3n y seguridad","text":"<p>Android 12 renov\u00f3 la est\u00e9tica con Material You, un sistema de colores din\u00e1micos basados en el fondo de pantalla. Tambi\u00e9n estren\u00f3 un panel de privacidad claro y actualizaciones m\u00e1s r\u00e1pidas mediante Google Play.  </p> <p>Android 13 reforz\u00f3 la seguridad, permiti\u00f3 elegir idiomas por aplicaci\u00f3n y mejor\u00f3 el portapapeles. Adem\u00e1s, potenci\u00f3 la personalizaci\u00f3n de la interfaz y a\u00f1adi\u00f3 mejoras en el audio y multimedia.</p> <p></p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/android/#android-14-2023-mas-control-y-conectividad","title":"Android 14 (2023): m\u00e1s control y conectividad","text":"<p>Con Android 14, Google puso el foco en la personalizaci\u00f3n de la pantalla de bloqueo, nuevos permisos m\u00e1s estrictos, conectividad v\u00eda sat\u00e9lite y soporte para Ultra HDR. Tambi\u00e9n limit\u00f3 las apps de 32 bits, impulsando una transici\u00f3n hacia un ecosistema m\u00e1s moderno y seguro.</p> <p></p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/android/#android-15-20242025-el-presente","title":"Android 15 (2024\u20132025): el presente","text":"<p>La \u00faltima versi\u00f3n, Android 15, contin\u00faa la senda de ofrecer un sistema m\u00e1s eficiente, seguro y adaptado a nuevas formas de uso. Entre sus novedades destacan:</p> <ul> <li>Mejor integraci\u00f3n con dispositivos plegables y pantallas de gran formato.  </li> <li>Nuevas funciones potenciadas por inteligencia artificial para personalizaci\u00f3n y productividad.  </li> <li>Refuerzo de la seguridad y la privacidad como ejes centrales.  </li> <li>Optimizaciones en consumo energ\u00e9tico y gesti\u00f3n de procesos.  </li> </ul> <p>Con Android 15, el sistema se prepara para una nueva etapa donde la IA y la conectividad avanzada ser\u00e1n protagonistas, manteniendo al mismo tiempo la esencia de ser una plataforma abierta y diversa.</p> <p></p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/android/#conclusion","title":"Conclusi\u00f3n","text":"<p>Desde aquel humilde HTC Dream hasta los actuales smartphones con pantallas plegables y funciones de IA, Android ha recorrido un camino fascinante. Cada versi\u00f3n trajo consigo innovaciones que, m\u00e1s all\u00e1 de competir con iOS, marcaron la evoluci\u00f3n de toda la industria m\u00f3vil. Hoy, con m\u00e1s de 3.000 millones de dispositivos activos, Android no es solo un sistema operativo: es un ecosistema global en constante transformaci\u00f3n.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/android/#resumen-de-versiones-de-android","title":"\ud83d\udcf1 Resumen de versiones de Android","text":"Versi\u00f3n A\u00f1o Nombre Principales novedades 1.0 2008 \u2013 Primera versi\u00f3n comercial (HTC Dream), Android Market, apps b\u00e1sicas de Google. 1.1 2009 \u2013 Adjuntar archivos en mensajes, mejoras de estabilidad. 1.5 2009 Cupcake Teclado virtual, widgets, subida de v\u00eddeos a YouTube. 1.6 2009 Donut B\u00fasqueda por voz/texto, soporte multiresoluci\u00f3n. 2.0\u20132.1 2009 Eclair Fondos animados, multitouch, Google Maps Navigation. 2.2 2010 Froyo Notificaciones push, apps en tarjeta SD, soporte Flash. 2.3 2010 Gingerbread Interfaz renovada, soporte NFC, mejoras en juegos y audio. 3.x 2011 Honeycomb Optimizado para tabletas, multitarea mejorada. 4.0 2011 Ice Cream Sandwich Unificaci\u00f3n m\u00f3vil/tablet, tipograf\u00eda Roboto, desbloqueo facial. 4.1\u20134.3 2012 Jelly Bean Proyecto Butter (fluidez), Google Now, notificaciones expandibles. 4.4 2013 KitKat Modo inmersivo, mejor soporte a gama baja. 5.0\u20135.1 2014 Lollipop Material Design, procesadores 64 bits, nuevas notificaciones. 6.0 2015 Marshmallow Permisos por app, huellas digitales, Android Pay. 7.0\u20137.1 2016 Nougat Multiventana, API Vulkan, mejor gesti\u00f3n bater\u00eda. 8.0\u20138.1 2017 Oreo Picture in Picture, iconos adaptativos, Project Treble. 9.0 2018 Pie Navegaci\u00f3n por gestos, Digital Wellbeing, IA adaptativa. 10.0 2019 \u2013 Modo oscuro, soporte 5G y plegables, Live Caption. 11.0 2020 \u2013 Burbujas de chat, control de dispositivos, permisos temporales. 12.0 2021 \u2013 Material You, panel de privacidad, capturas con desplazamiento. 13.0 2022 \u2013 Idiomas por app, mejoras en portapapeles y seguridad. 14.0 2023 \u2013 Conectividad satelital, Ultra HDR, adi\u00f3s apps 32 bits. 15.0 2024 \u2013 IA m\u00e1s integrada, mejoras en plegables, m\u00e1s seguridad."},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/android_studio/","title":"Android Studio","text":""},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/android_studio/#introduccion","title":"Introducci\u00f3n","text":"<p>Android Studio es el IDE oficial para el desarrollo de aplicaciones Android. Basado en IntelliJ IDEA, fue lanzado por Google en 2013 y desde entonces se ha convertido en la herramienta est\u00e1ndar para programar en Kotlin y Java. Ofrece un entorno completo para crear, probar y distribuir aplicaciones m\u00f3viles.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/android_studio/#caracteristicas-principales","title":"Caracter\u00edsticas principales","text":"<ul> <li>Editor de c\u00f3digo inteligente con autocompletado y refactorizaci\u00f3n.  </li> <li>Simuladores de dispositivos Android para pruebas sin hardware f\u00edsico.  </li> <li>Integraci\u00f3n con el SDK de Android y librer\u00edas de Jetpack.  </li> <li>Soporte nativo para Kotlin y Jetpack Compose.  </li> <li>Herramientas de profiling para medir rendimiento, memoria y consumo energ\u00e9tico.  </li> <li>Integraci\u00f3n con sistemas de control de versiones como Git.  </li> </ul>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/android_studio/#estructura-de-un-proyecto-en-android-studio","title":"Estructura de un proyecto en Android Studio","text":"<p>Cuando se crea un nuevo proyecto, Android Studio organiza los archivos en varias carpetas. Las m\u00e1s importantes son:</p> <ul> <li>app/   Carpeta principal de la aplicaci\u00f3n. Contiene el c\u00f3digo fuente, recursos y archivos de configuraci\u00f3n espec\u00edficos.  </li> <li> <p>src/: c\u00f3digo fuente de la aplicaci\u00f3n.  </p> <ul> <li>main/:  </li> <li>java/: c\u00f3digo en Kotlin o Java.  </li> <li>res/: recursos (layouts XML, im\u00e1genes, cadenas de texto, iconos, etc.).  </li> <li>AndroidManifest.xml: archivo de configuraci\u00f3n con permisos, actividades y metadatos de la app.  </li> <li>test/: pruebas unitarias.  </li> <li>androidTest/: pruebas de instrumentaci\u00f3n (en dispositivo o emulador).  </li> </ul> </li> <li> <p>gradle/   Archivos de configuraci\u00f3n de Gradle, el sistema de construcci\u00f3n que compila y empaqueta la app.  </p> </li> <li> <p>build/   Carpeta generada autom\u00e1ticamente que contiene los archivos compilados.  </p> </li> <li> <p>.idea/   Configuraci\u00f3n del proyecto en IntelliJ/Android Studio.  </p> </li> </ul> <p>Esta estructura permite separar claramente el c\u00f3digo, los recursos y las configuraciones del proyecto.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/dispositivos_moviles/","title":"Dispositivos m\u00f3viles","text":""},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/dispositivos_moviles/#los-origenes-de-la-comunicacion-a-distancia","title":"Los or\u00edgenes de la comunicaci\u00f3n a distancia","text":"<p>El camino hacia los dispositivos m\u00f3viles comienza con los primeros intentos de transmitir la voz a distancia. El tel\u00e9grafo abri\u00f3 la puerta a una nueva era de comunicaci\u00f3n r\u00e1pida, pero fue el tel\u00e9fono de Graham Bell, patentado en 1876, el que marc\u00f3 el inicio de las telecomunicaciones modernas. Este invento permiti\u00f3 que dos personas se comunicaran en tiempo real a trav\u00e9s de largas distancias, estableciendo las bases para todo lo que vendr\u00eda despu\u00e9s.  </p> <p></p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/dispositivos_moviles/#alexander-graham-bell","title":"Alexander Graham Bell","text":"<p>Alexander Graham Bell (1847\u20131922) fue un cient\u00edfico e inventor escoc\u00e9s-estadounidense. Es mundialmente conocido por la invenci\u00f3n del tel\u00e9fono, patente que registr\u00f3 en 1876. Adem\u00e1s de sus aportes en telecomunicaciones, trabaj\u00f3 en proyectos relacionados con la ense\u00f1anza a personas sordas, la aerona\u00fatica y la \u00f3ptica. Su legado est\u00e1 marcado por la creaci\u00f3n de la Bell Telephone Company, que se convertir\u00eda en una de las compa\u00f1\u00edas m\u00e1s influyentes del sector.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/dispositivos_moviles/#antonio-meucci","title":"Antonio Meucci","text":"<p>Antonio Meucci (1808\u20131889) fue un inventor italiano que desarroll\u00f3 un dispositivo precursor del tel\u00e9fono al que llam\u00f3 teletr\u00f3fono en 1854. Por dificultades econ\u00f3micas, no pudo pagar la patente definitiva de su invento y solo registr\u00f3 una advertencia de patente (caveat) en 1871 en Estados Unidos. Durante a\u00f1os, su papel en la invenci\u00f3n del tel\u00e9fono fue ignorado, pero en 2002 el Congreso de los Estados Unidos reconoci\u00f3 oficialmente la contribuci\u00f3n de Meucci a la telefon\u00eda.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/dispositivos_moviles/#el-teletrofono-y-las-primeras-ideas-moviles","title":"El teletr\u00f3fono y las primeras ideas m\u00f3viles","text":"<p>Antes de que existieran los tel\u00e9fonos inal\u00e1mbricos modernos, hubo experimentos como el teletr\u00f3fono, un dispositivo rudimentario que propon\u00eda llevar la comunicaci\u00f3n m\u00e1s all\u00e1 del cable fijo. Aunque sus limitaciones t\u00e9cnicas no lo hicieron pr\u00e1ctico, es un ejemplo de c\u00f3mo la idea de movilidad ya estaba presente en el siglo XIX.  </p> <p></p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/dispositivos_moviles/#martin-cooper-y-el-primer-telefono-movil","title":"Martin Cooper y el primer tel\u00e9fono m\u00f3vil","text":"<p>En 1973, Martin Cooper, ingeniero de Motorola, realiz\u00f3 la primera llamada desde un tel\u00e9fono m\u00f3vil port\u00e1til. El dispositivo era grande y pesado (m\u00e1s de un kilo), pero sent\u00f3 las bases para lo que hoy conocemos como telefon\u00eda m\u00f3vil. Este hito marc\u00f3 el inicio de una nueva etapa: la comunicaci\u00f3n sin cables.  </p> <p></p> <p>Martin Cooper (1928\u2013) es un ingeniero e ejecutivo estadounidense conocido como el padre del tel\u00e9fono m\u00f3vil. En 1973, mientras trabajaba en Motorola, realiz\u00f3 la primera llamada desde un tel\u00e9fono m\u00f3vil port\u00e1til, usando un dispositivo que pesaba m\u00e1s de un kilo y med\u00eda m\u00e1s de 25 cent\u00edmetros. Su innovaci\u00f3n marc\u00f3 el inicio de la era de la telefon\u00eda celular y transform\u00f3 para siempre la forma en que nos comunicamos. Cooper continu\u00f3 su carrera en el campo de las telecomunicaciones y es considerado una de las figuras clave en el desarrollo de las comunicaciones inal\u00e1mbricas modernas.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/dispositivos_moviles/#la-llegada-de-las-aplicaciones","title":"La llegada de las aplicaciones","text":"<p>Con el avance de la tecnolog\u00eda, los m\u00f3viles dejaron de ser simples herramientas de voz. Surgieron las aplicaciones, que ampliaron sus funciones hacia el entretenimiento, la productividad y la conectividad. Primero aparecieron las aplicaciones m\u00e1s b\u00e1sicas: calculadoras, calendarios, juegos simples. Luego, con la expansi\u00f3n de internet, se incorporaron aplicaciones m\u00e1s complejas y conectadas.  </p> <p></p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/dispositivos_moviles/#aplicaciones-web","title":"Aplicaciones web","text":"<p>Las primeras aplicaciones que funcionaban sobre m\u00f3viles conectados a internet fueron las aplicaciones web. Estas no se instalaban en el dispositivo, sino que se ejecutaban en el navegador. Ofrec\u00edan acceso universal y facilidad de uso, pero estaban limitadas por la conectividad y por la capacidad del navegador.  </p> <p></p> <p></p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/dispositivos_moviles/#aplicaciones-hibridas","title":"Aplicaciones h\u00edbridas","text":"<p>Despu\u00e9s surgieron las aplicaciones h\u00edbridas, que combinaban la flexibilidad del desarrollo web con el acceso a funciones del dispositivo. Se constru\u00edan con tecnolog\u00edas web (HTML, CSS, JavaScript) y se empaquetaban en un contenedor nativo, lo que les permit\u00eda instalarse y funcionar incluso sin conexi\u00f3n.  </p> <p></p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/dispositivos_moviles/#aplicaciones-web-progresivas-pwa","title":"Aplicaciones web progresivas (PWA)","text":"<p>Las PWA representaron un paso intermedio entre lo web y lo nativo. Son aplicaciones web que se comportan como aplicaciones instaladas: permiten notificaciones push, funcionan offline y ofrecen una experiencia de usuario muy cercana a la de una app tradicional.  </p> <p></p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/dispositivos_moviles/#aplicaciones-nativas","title":"Aplicaciones nativas","text":"<p>Finalmente, las aplicaciones nativas marcaron un antes y un despu\u00e9s. Estas aplicaciones est\u00e1n dise\u00f1adas espec\u00edficamente para cada sistema operativo (iOS, Android), lo que permite aprovechar al m\u00e1ximo el hardware y las capacidades del dispositivo. Ofrecen mejor rendimiento, seguridad y experiencia de usuario, convirti\u00e9ndose en el est\u00e1ndar de facto de la telefon\u00eda moderna.  </p> <p></p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/dispositivos_moviles/#caracteristicas-webapps-apps-hibridas-apps-nativas","title":"Caracter\u00edsticas WebApps, Apps h\u00edbridas, Apps nativas","text":""},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/estableciendo_criterios/","title":"Estableciendo criterios","text":"<p>Informaci\u00f3n para establecer criterios de elecci\u00f3n:</p> <p>Desarrollo Front-End</p> <p>El front-end es la parte de la aplicaci\u00f3n que interact\u00faa directamente con el usuario y se ejecuta en el navegador. Los lenguajes y frameworks para el desarrollo front-end deben proporcionar una experiencia de usuario fluida y responsiva.</p> <p>Lenguajes de Programaci\u00f3n:</p> <ul> <li> <p>HTML: Lenguaje de marcado que estructura el contenido de la     aplicaci\u00f3n web.</p> </li> <li> <p>CSS: Lenguaje de estilos utilizado para dar formato y dise\u00f1o a     la interfaz.</p> </li> <li> <p>JavaScript: Lenguaje principal para la programaci\u00f3n en el     navegador que permite interactividad y l\u00f3gica en el front-end.</p> </li> </ul> <p>Frameworks/Bibliotecas:</p> <ol> <li> <p>React (JavaScript)</p> <ul> <li> <p>Descripci\u00f3n: Biblioteca de JavaScript desarrollada por     Facebook. Es ideal para crear interfaces de usuario din\u00e1micas y     componentes reutilizables.</p> </li> <li> <p>Ventajas: Excelente para aplicaciones de una sola p\u00e1gina     (SPA) y cuenta con una amplia comunidad y ecosistema.</p> </li> </ul> </li> <li> <p>Angular (TypeScript)</p> <ul> <li> <p>Descripci\u00f3n: Framework de desarrollo de aplicaciones     desarrollado por Google que utiliza TypeScript.</p> </li> <li> <p>Ventajas: Ofrece una estructura muy completa para el     desarrollo de aplicaciones front-end y es excelente para     aplicaciones grandes y complejas.</p> </li> </ul> </li> <li> <p>Vue.js (JavaScript)</p> <ul> <li> <p>Descripci\u00f3n: Framework progresivo para la construcci\u00f3n de     interfaces de usuario que es f\u00e1cil de aprender y muy flexible.</p> </li> <li> <p>Ventajas: Es ligero, r\u00e1pido y ofrece una curva de     aprendizaje m\u00e1s suave que Angular o React.</p> </li> </ul> </li> <li> <p>Svelte (JavaScript)</p> <ul> <li> <p>Descripci\u00f3n: Framework relativamente nuevo que compila el     c\u00f3digo en JavaScript puro en tiempo de compilaci\u00f3n, lo que     resulta en una aplicaci\u00f3n m\u00e1s r\u00e1pida y ligera.</p> </li> <li> <p>Ventajas: Ofrece excelente rendimiento y simplifica la     creaci\u00f3n de componentes.</p> </li> </ul> </li> </ol> <p>Desarrollo Back-End</p> <p>El back-end es la parte de la aplicaci\u00f3n que se ejecuta en el servidor, gestionando la l\u00f3gica de la aplicaci\u00f3n, las interacciones con la base de datos, la autenticaci\u00f3n y m\u00e1s.</p> <p>Lenguajes de Programaci\u00f3n:</p> <ul> <li> <p>JavaScript (Node.js): Permite usar el mismo lenguaje para el     front-end y back-end, facilitando el desarrollo de aplicaciones     completas.</p> </li> <li> <p>Python: Popular por su legibilidad y amplia gama de bibliotecas     y frameworks.</p> </li> <li> <p>Java: Confiable, escalable y ampliamente utilizado en     aplicaciones empresariales.</p> </li> <li> <p>Ruby: Lenguaje din\u00e1mico y f\u00e1cil de usar, a menudo utilizado en     combinaci\u00f3n con el framework Rails.</p> </li> <li> <p>PHP: Lenguaje ampliamente utilizado para el desarrollo web,     especialmente en sistemas de gesti\u00f3n de contenido como WordPress.</p> </li> </ul> <p>Frameworks/Plataformas:</p> <ol> <li> <p>Node.js (JavaScript)</p> <ul> <li> <p>Descripci\u00f3n: Entorno de ejecuci\u00f3n que permite usar     JavaScript en el lado del servidor.</p> </li> <li> <p>Ventajas: Altamente eficiente, ideal para aplicaciones en     tiempo real como chats y es compatible con frameworks como     Express.js.</p> </li> </ul> </li> <li> <p>Django (Python)</p> <ul> <li> <p>Descripci\u00f3n: Framework web completo que sigue el patr\u00f3n MVC     (Model-View-Controller).</p> </li> <li> <p>Ventajas: Proporciona un conjunto completo de herramientas y     es excelente para construir aplicaciones web seguras y     escalables.</p> </li> </ul> </li> <li> <p>Spring Boot (Java)</p> <ul> <li> <p>Descripci\u00f3n: Framework basado en Java que simplifica la     configuraci\u00f3n y el desarrollo de aplicaciones web y de     microservicios.</p> </li> <li> <p>Ventajas: Ideal para aplicaciones empresariales y sistemas     de gran escala.</p> </li> </ul> </li> <li> <p>Ruby on Rails (Ruby)</p> <ul> <li> <p>Descripci\u00f3n: Framework de desarrollo web que sigue el     enfoque \\\"convenci\u00f3n sobre configuraci\u00f3n\\\".</p> </li> <li> <p>Ventajas: Permite un desarrollo r\u00e1pido de prototipos y es     popular por su simplicidad y eficiencia.</p> </li> </ul> </li> <li> <p>Laravel (PHP)</p> <ul> <li> <p>Descripci\u00f3n: Framework web que ofrece un entorno sencillo y     elegante para desarrollar aplicaciones basadas en PHP.</p> </li> <li> <p>Ventajas: F\u00e1cil de usar y proporciona muchas funcionalidades     predefinidas como autenticaci\u00f3n y gesti\u00f3n de bases de datos.</p> </li> </ul> </li> </ol> <p>Combinaciones Populares para Full-Stack:</p> <ul> <li> <p>MERN Stack: MongoDB (Base de datos) + Express.js (Back-end) +     React (Front-end) + Node.js (Servidor)</p> </li> <li> <p>MEAN Stack: MongoDB + Express.js + Angular + Node.js</p> </li> <li> <p>LAMP Stack: Linux (Sistema Operativo) + Apache (Servidor Web) +     MySQL (Base de datos) + PHP (Back-end)</p> </li> <li> <p>Django + React/Vue: Utilizando Django para la l\u00f3gica del     back-end y React o Vue.js para la parte del front-end.</p> </li> </ul> <p>Frameworks y Lenguajes para Desarrollo Web y Aplicaciones M\u00f3viles (m\u00e1s criterios de selecci\u00f3n)</p> <p>1. Laravel (PHP)</p> <ul> <li> <p>Descripci\u00f3n: Laravel es un framework de desarrollo web basado en     PHP que sigue el patr\u00f3n MVC (Model-View-Controller). Ofrece un     conjunto completo de herramientas que facilitan el desarrollo de     aplicaciones web, como autenticaci\u00f3n, enrutamiento, sesiones, y     controladores de bases de datos.</p> </li> <li> <p>Cu\u00e1ndo usarlo:</p> <ul> <li> <p>Para desarrollar aplicaciones web de manera r\u00e1pida y con     funcionalidades integradas como autenticaci\u00f3n y gesti\u00f3n de bases     de datos.</p> </li> <li> <p>Cuando se busca un framework con una curva de aprendizaje     moderada y una comunidad activa.</p> </li> <li> <p>Ideal para proyectos de tama\u00f1o medio y grande, como sistemas de     gesti\u00f3n de contenidos o aplicaciones de comercio electr\u00f3nico.</p> </li> </ul> </li> </ul> <p>2. Ionic (JavaScript/TypeScript)</p> <ul> <li> <p>Descripci\u00f3n: Ionic es un framework para el desarrollo de     aplicaciones m\u00f3viles h\u00edbridas que utiliza tecnolog\u00edas web (HTML,     CSS, y JavaScript/TypeScript). Se basa en el uso de componentes UI     que se renderizan a trav\u00e9s de un motor web (WebView).</p> </li> <li> <p>Cu\u00e1ndo usarlo:</p> <ul> <li> <p>Cuando se desea desarrollar una aplicaci\u00f3n que funcione en     m\u00faltiples plataformas (Android, iOS y web) a partir de una \u00fanica     base de c\u00f3digo.</p> </li> <li> <p>Ideal para aplicaciones que no necesitan un rendimiento muy alto     y donde es importante reducir los costos y el tiempo de     desarrollo.</p> </li> <li> <p>Se integra bien con frameworks como Angular, React o Vue.js.</p> </li> </ul> </li> </ul> <p>3. React Native (JavaScript/TypeScript)</p> <ul> <li> <p>Descripci\u00f3n: React Native es un framework de desarrollo m\u00f3vil     que permite crear aplicaciones nativas utilizando JavaScript y     React. A diferencia de Ionic, React Native compila a componentes     nativos de la plataforma, proporcionando una experiencia de usuario     m\u00e1s cercana a una aplicaci\u00f3n nativa.</p> </li> <li> <p>Cu\u00e1ndo usarlo:</p> <ul> <li> <p>Cuando se necesita un rendimiento y experiencia de usuario     nativos, pero se desea desarrollar con JavaScript.</p> </li> <li> <p>Ideal para crear aplicaciones multiplataforma que requieran un     aspecto y un rendimiento muy similar a las aplicaciones nativas.</p> </li> <li> <p>Es una excelente opci\u00f3n si ya tienes experiencia con React para     desarrollo web, ya que la sintaxis es muy similar.</p> </li> </ul> </li> </ul> <p>4. Flutter (Dart)</p> <ul> <li> <p>Descripci\u00f3n: Flutter es un framework de desarrollo de     aplicaciones m\u00f3viles creado por Google que utiliza el lenguaje de     programaci\u00f3n Dart. Permite la creaci\u00f3n de aplicaciones nativas para     Android e iOS desde una sola base de c\u00f3digo y utiliza su propio     motor de renderizado para construir la interfaz de usuario.</p> </li> <li> <p>Cu\u00e1ndo usarlo:</p> <ul> <li> <p>Cuando se busca un rendimiento muy cercano a una aplicaci\u00f3n     nativa y se necesita desarrollar para m\u00faltiples plataformas     (Android, iOS, web y escritorio).</p> </li> <li> <p>Ideal para interfaces personalizadas y animaciones complejas.</p> </li> <li> <p>Es una excelente opci\u00f3n si se desea trabajar con un framework     que ofrece un alto rendimiento y un conjunto completo de     herramientas para el desarrollo.</p> </li> </ul> </li> </ul> <p>5. Kotlin (para Android)</p> <ul> <li> <p>Descripci\u00f3n: Kotlin es un lenguaje de programaci\u00f3n moderno y     oficial para el desarrollo de aplicaciones Android. Es totalmente     compatible con Java y se puede usar para desarrollar aplicaciones     nativas de Android.</p> </li> <li> <p>Cu\u00e1ndo usarlo:</p> <ul> <li> <p>Cuando se busca desarrollar una aplicaci\u00f3n nativa para Android     con un lenguaje que sea seguro, conciso y m\u00e1s moderno que Java.</p> </li> <li> <p>Ideal para desarrolladores que trabajan exclusivamente en el     ecosistema Android y desean aprovechar al m\u00e1ximo las     caracter\u00edsticas nativas de la plataforma.</p> </li> <li> <p>Es ampliamente utilizado en aplicaciones que necesitan un     rendimiento nativo y la \u00faltima funcionalidad de Android.</p> </li> </ul> </li> </ul> <p>6. Swift (para iOS)</p> <ul> <li> <p>Descripci\u00f3n: Swift es el lenguaje de programaci\u00f3n oficial para     el desarrollo de aplicaciones nativas de iOS. Fue creado por Apple y     ofrece un alto rendimiento y seguridad.</p> </li> <li> <p>Cu\u00e1ndo usarlo:</p> <ul> <li> <p>Cuando se desarrolla exclusivamente para la plataforma iOS y se     necesita un rendimiento y acceso completo a las funciones     nativas.</p> </li> <li> <p>Es la mejor opci\u00f3n para proyectos que buscan aprovechar todas     las caracter\u00edsticas m\u00e1s recientes del ecosistema de Apple y     requieren una experiencia de usuario optimizada.</p> </li> </ul> </li> </ul> <p>Comparaci\u00f3n R\u00e1pida:</p> <p></p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/frameworks_desarrollo/","title":"Frameworks de desarrollo para aplicaciones m\u00f3viles","text":""},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/frameworks_desarrollo/#introduccion","title":"Introducci\u00f3n","text":"<p>Adem\u00e1s de los lenguajes de programaci\u00f3n, un aspecto clave en el desarrollo de aplicaciones m\u00f3viles es el uso de frameworks. Estos proporcionan estructuras, librer\u00edas y utilidades que simplifican la creaci\u00f3n de apps, fomentan buenas pr\u00e1cticas y aceleran el ciclo de desarrollo. En este apartado veremos los frameworks m\u00e1s importantes vinculados a Kotlin (Android) y Swift (iOS), entendiendo su papel en el d\u00eda a d\u00eda de los desarrolladores y sus aportaciones al ecosistema.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/frameworks_desarrollo/#frameworks-en-kotlin-android","title":"Frameworks en Kotlin (Android)","text":""},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/frameworks_desarrollo/#android-jetpack","title":"Android Jetpack","text":"<p>Android Jetpack no es un framework \u00fanico, sino un conjunto de librer\u00edas, herramientas y gu\u00edas de arquitectura desarrolladas por Google. Incluye componentes como Room (persistencia de datos), ViewModel y LiveData (gesti\u00f3n del ciclo de vida y datos reactivos) o Navigation (manejo de rutas). Jetpack promueve el desarrollo basado en principios modernos como la separaci\u00f3n de responsabilidades y la escalabilidad.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/frameworks_desarrollo/#kotlin-coroutines","title":"Kotlin Coroutines","text":"<p>El soporte de Kotlin Coroutines permite gestionar operaciones as\u00edncronas y concurrentes de manera m\u00e1s sencilla y expresiva que con threads tradicionales. Gracias a las corutinas, los desarrolladores pueden trabajar con llamadas a red, acceso a bases de datos o tareas en segundo plano sin complicar el c\u00f3digo con callbacks.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/frameworks_desarrollo/#ktor","title":"Ktor","text":"<p>Ktor es un framework creado por JetBrains para desarrollar aplicaciones cliente-servidor en Kotlin. En el \u00e1mbito m\u00f3vil es especialmente \u00fatil para la comunicaci\u00f3n con APIs REST o WebSocket, permitiendo a los desarrolladores de Android (y multiplataforma) trabajar con redes de forma segura y modular.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/frameworks_desarrollo/#jetpack-compose","title":"Jetpack Compose","text":"<p>Jetpack Compose es el framework declarativo moderno de Android para construir interfaces gr\u00e1ficas en Kotlin. Inspirado en paradigmas como React y SwiftUI, Compose simplifica la creaci\u00f3n de UIs reactivas, eliminando gran parte de la complejidad del manejo de Views tradicionales.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/frameworks_desarrollo/#frameworks-en-swift-ios","title":"Frameworks en Swift (iOS)","text":""},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/frameworks_desarrollo/#uikit","title":"UIKit","text":"<p>UIKit ha sido durante m\u00e1s de una d\u00e9cada el framework central para el desarrollo de interfaces en iOS. Proporciona todos los componentes b\u00e1sicos de la interfaz gr\u00e1fica (botones, vistas, controles de navegaci\u00f3n) y maneja aspectos fundamentales como gestos t\u00e1ctiles, animaciones o gesti\u00f3n del ciclo de vida de las vistas.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/frameworks_desarrollo/#swiftui","title":"SwiftUI","text":"<p>Presentado en 2019, SwiftUI representa el salto hacia un modelo declarativo en el desarrollo de interfaces. Permite construir pantallas con c\u00f3digo conciso y reactivo, donde la UI se actualiza autom\u00e1ticamente al cambiar el estado de los datos. SwiftUI se integra con Combine para manejar programaci\u00f3n reactiva y es considerado el futuro del desarrollo en plataformas Apple.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/frameworks_desarrollo/#combine","title":"Combine","text":"<p>Combine es un framework para programaci\u00f3n reactiva introducido en iOS 13. Ofrece una manera unificada de manejar eventos asincr\u00f3nicos, como actualizaciones de red, entradas del usuario o cambios en la base de datos. Aunque se usa frecuentemente junto a SwiftUI, tambi\u00e9n puede integrarse con UIKit, ofreciendo m\u00e1s control sobre flujos de datos complejos.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/frameworks_desarrollo/#core-data","title":"Core Data","text":"<p>Core Data es el framework de persistencia nativo de Apple. Permite modelar datos de alto nivel y almacenarlos de forma eficiente, integr\u00e1ndose perfectamente con Swift y SwiftUI. Aunque tiene cierta curva de aprendizaje, es la soluci\u00f3n m\u00e1s adoptada para la gesti\u00f3n local de datos en apps iOS.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/frameworks_desarrollo/#entornos-de-desarrollo-integrados-ides-para-kotlin-y-swift","title":"Entornos de desarrollo integrados (IDEs) para Kotlin y Swift","text":""},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/frameworks_desarrollo/#introduccion_1","title":"Introducci\u00f3n","text":"<p>El IDE (Integrated Development Environment) es la herramienta central de todo desarrollador. Un buen IDE no solo ofrece un editor de c\u00f3digo, sino tambi\u00e9n depuraci\u00f3n, simuladores, pruebas automatizadas, gesti\u00f3n de dependencias y despliegue en dispositivos. Veamos cu\u00e1les son los entornos m\u00e1s utilizados al programar con Kotlin y Swift, y por qu\u00e9 son fundamentales en el d\u00eda a d\u00eda del desarrollo m\u00f3vil.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/frameworks_desarrollo/#ides-para-kotlin-android","title":"IDEs para Kotlin (Android)","text":""},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/frameworks_desarrollo/#android-studio","title":"Android Studio","text":"<p>Android Studio es el IDE oficial para el desarrollo en Android. Basado en IntelliJ IDEA, incluye soporte completo para Kotlin desde 2017. Sus principales caracter\u00edsticas son: - Integraci\u00f3n con Android SDK y herramientas de compilaci\u00f3n. - Soporte de Jetpack Compose para crear interfaces modernas de forma declarativa. - Simuladores de dispositivos para pruebas sin necesidad de hardware f\u00edsico. - Potente depurador, analizador de rendimiento y herramientas de profiling. - Integraci\u00f3n con Git y servicios en la nube de Google.  </p> <p>En la pr\u00e1ctica, es la opci\u00f3n m\u00e1s usada por los desarrolladores Android, tanto principiantes como profesionales.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/frameworks_desarrollo/#intellij-idea","title":"IntelliJ IDEA","text":"<p>Aunque Android Studio est\u00e1 basado en \u00e9l, IntelliJ IDEA es el IDE insignia de JetBrains y ofrece un entorno m\u00e1s generalista para Kotlin, ideal si se trabaja en proyectos multiplataforma (Android + backend en Ktor, por ejemplo). Es especialmente valorado por sus herramientas de refactorizaci\u00f3n y productividad.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/frameworks_desarrollo/#ides-para-swift-ios","title":"IDEs para Swift (iOS)","text":""},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/frameworks_desarrollo/#xcode","title":"Xcode","text":"<p>Xcode es el IDE oficial de Apple y la opci\u00f3n dominante para programar en Swift. Incluye: - Simuladores de todos los dispositivos Apple (iPhone, iPad, Apple Watch, Apple TV, Mac). - Herramientas visuales para dise\u00f1ar interfaces con Storyboard o con SwiftUI Preview. - Depurador integrado, pruebas unitarias y de interfaz, an\u00e1lisis de rendimiento. - Integraci\u00f3n directa con la App Store para distribuir aplicaciones.  </p> <p>En el ecosistema Apple, Xcode es pr\u00e1cticamente obligatorio, ya que es el \u00fanico IDE que permite compilar y desplegar apps en dispositivos iOS de forma oficial.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/frameworks_desarrollo/#appcode","title":"AppCode","text":"<p>AppCode, desarrollado por JetBrains, es una alternativa a Xcode que se integra con el ecosistema de JetBrains. Ofrece: - Soporte avanzado de refactorizaci\u00f3n y navegaci\u00f3n en proyectos grandes. - Integraci\u00f3n con Swift, Objective-C y C++. - Compatibilidad con las herramientas de Apple (usa Xcode por debajo para la compilaci\u00f3n).  </p> <p>Aunque es menos utilizado que Xcode, algunos equipos lo prefieren por las ventajas de productividad t\u00edpicas de JetBrains.</p> <p>Android Studio</p> <p>XCode</p> <p>CRITERIOS</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/kotlin/","title":"Kotlin","text":""},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/kotlin/#kotlin-el-aliado-moderno-de-android","title":"Kotlin: el aliado moderno de Android","text":""},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/kotlin/#introduccion","title":"Introducci\u00f3n","text":"<p>Kotlin es un lenguaje de programaci\u00f3n moderno, conciso y expresivo creado por JetBrains. Aunque puede utilizarse para aplicaciones de servidor, de escritorio o incluso multiplataforma, su papel estelar lo ocupa en el ecosistema Android, donde desde 2017 es un lenguaje oficial junto a Java.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/kotlin/#historia","title":"Historia","text":"<p>El proyecto Kotlin comenz\u00f3 en 2010 dentro de JetBrains, la compa\u00f1\u00eda detr\u00e1s de herramientas como IntelliJ IDEA. En 2016 se lanz\u00f3 la versi\u00f3n 1.0, pero el verdadero punto de inflexi\u00f3n lleg\u00f3 en el Google I/O 2017, cuando Google anunci\u00f3 a Kotlin como lenguaje oficial para Android. Desde ese momento, su adopci\u00f3n ha crecido r\u00e1pidamente gracias a su sintaxis clara, la interoperabilidad total con Java y el soporte oficial en Android Studio.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/kotlin/#caracteristicas-principales","title":"Caracter\u00edsticas principales","text":"<ul> <li>Sintaxis concisa y legible, que reduce el c\u00f3digo repetitivo t\u00edpico en Java.  </li> <li>Interoperabilidad con Java: permite usar librer\u00edas y proyectos existentes sin problemas.  </li> <li>Programaci\u00f3n funcional y orientada a objetos: soporta lambdas, funciones de extensi\u00f3n y colecciones inmutables.  </li> <li>Seguridad frente a null: su sistema de tipos reduce los temidos NullPointerException.  </li> <li>Compatibilidad multiplataforma: con Kotlin Multiplatform, un mismo c\u00f3digo puede ejecutarse en Android, iOS, web y backend.  </li> <li>Soporte oficial de Google y JetBrains, lo que garantiza continuidad y mejoras constantes.</li> </ul>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/kotlin/#ventajas","title":"Ventajas","text":"<ul> <li>Curva de aprendizaje r\u00e1pida para quienes ya conocen Java.  </li> <li>Comunidad activa y abundante documentaci\u00f3n.  </li> <li>C\u00f3digo m\u00e1s limpio, mantenible y menos propenso a errores.  </li> <li>Gran integraci\u00f3n con las herramientas de desarrollo Android.  </li> </ul>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/kotlin/#desventajas","title":"Desventajas","text":"<ul> <li>Ecosistema multiplataforma a\u00fan en evoluci\u00f3n, con limitaciones en ciertas librer\u00edas.  </li> <li>Compilaci\u00f3n en algunos contextos m\u00e1s lenta que en Java.  </li> <li>Aunque crece cada vez m\u00e1s, su comunidad sigue siendo menor que la de Java.  </li> </ul> <p>Documentaci\u00f3n</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/lenguajes_programacion/","title":"Lenguajes de programaci\u00f3n para aplicaciones m\u00f3viles","text":""},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/lenguajes_programacion/#introduccion","title":"Introducci\u00f3n","text":"<p>Cuando pensamos en una app m\u00f3vil hoy en d\u00eda, damos por hecho que abrir\u00e1 al instante, que la navegaci\u00f3n ser\u00e1 fluida y que podr\u00e1 acceder a c\u00e1mara, sensores, red y notificaciones sin fricciones. No siempre fue as\u00ed. Detr\u00e1s de esa experiencia hay una historia de lenguajes que fueron evolucionando a medida que los dispositivos ganaban potencia y las expectativas de los usuarios crec\u00edan. Desde Java ME y los SDK propietarios de los primeros tel\u00e9fonos hasta Kotlin (Android) y Swift (iOS), la programaci\u00f3n m\u00f3vil ha pasado por varias generaciones marcadas por la seguridad, la productividad y el rendimiento.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/lenguajes_programacion/#los-primeros-anos-java-me-symbian-c-y-entornos-propietarios","title":"Los primeros a\u00f1os: Java ME, Symbian C++ y entornos propietarios","text":"<p>A finales de los 90 y comienzos de los 2000, los llamados feature phones ejecutaban aplicaciones peque\u00f1as: juegos sencillos, utilidades b\u00e1sicas y poco m\u00e1s. Java Micro Edition (Java ME) se convirti\u00f3 en el est\u00e1ndar de facto para distribuir MIDlets en multitud de dispositivos con memoria y CPU muy limitadas. En paralelo, Symbian (muy popular en Nokia) permit\u00eda desarrollo en C++, y cada fabricante ofrec\u00eda SDKs y APIs propios (BREW, Series 40/60, etc.). El resultado: fragmentaci\u00f3n y una experiencia de desarrollo muy dispar.</p> <ul> <li>Limitaciones clave de esta etapa:</li> <li>UIs muy b\u00e1sicas y poco uniformes.</li> <li>APIs inconsistentes entre fabricantes.</li> <li>Restricciones de memoria/almacenamiento que condicionaban el dise\u00f1o de las apps.</li> </ul>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/lenguajes_programacion/#el-punto-de-inflexion-20072009-iphoneobjective-c-y-androidjava","title":"El punto de inflexi\u00f3n (2007\u20132009): iPhone/Objective-C y Android/Java","text":"<p>2007: Apple lanza el iPhone y, con \u00e9l, un SDK centrado en Objective-C (un derivado de C con messaging al estilo Smalltalk). Aunque su sintaxis puede resultar verbosa, ofrec\u00eda: - Acceso estructurado al UI toolkit (UIKit), al ciclo de vida de las apps y a APIs de sistema bien dise\u00f1adas. - Un ecosistema de herramientas (Xcode, Instruments) muy integrado.</p> <p>2008: Google publica Android y apuesta por Java sobre una m\u00e1quina virtual optimizada para dispositivos (primero Dalvik, luego ART). Esto trajo: - Un pool de desarrolladores enorme que ya conoc\u00edan Java. - Una curva de adopci\u00f3n r\u00e1pida y un marketplace (Android Market \u2192 Google Play) con baja fricci\u00f3n de entrada.</p> <p>Ambos ecosistemas consolidaron el desarrollo nativo, con control fino sobre recursos y rendimiento.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/lenguajes_programacion/#evolucion-de-necesidades-y-del-diseno-de-lenguajes","title":"Evoluci\u00f3n de necesidades y del dise\u00f1o de lenguajes","text":"<p>A medida que las apps se hicieron m\u00e1s complejas (multimedia, gr\u00e1ficos acelerados, redes sociales, banca, comercio, cifrado), crecieron las exigencias:</p> <ul> <li>Seguridad: gesti\u00f3n de memoria m\u00e1s segura, tipos m\u00e1s expresivos, reducci\u00f3n de null pointer exceptions.</li> <li>Productividad: menos boilerplate, inferencia de tipos, mejores sistemas de m\u00f3dulos y build.</li> <li>Concurrencia: modelos de asincron\u00eda m\u00e1s legibles (futuros, promises, coroutines, GCD).</li> <li>UI declarativa: describir interfaces como funciones del estado (SwiftUI, Jetpack Compose).</li> </ul> <p>Objective-C y Java cumplieron una etapa esencial, pero el sector ped\u00eda un relevo generacional.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/lenguajes_programacion/#el-relevo-en-ios-swift-2014","title":"El relevo en iOS: Swift (2014 \u2192 \u2026)","text":"<p>En 2014, Apple presenta Swift: moderno, expresivo y con foco en la seguridad (tipos opcionales, control de errores, value semantics cada vez m\u00e1s frecuentes). Adem\u00e1s: - Interoperable con Objective-C, facilitando migraciones graduales. - Ecosistema en expansi\u00f3n: Swift Package Manager, SwiftUI (UI declarativa), extensiones de lenguaje y mejoras de rendimiento continuas.</p> <p>Ejemplo r\u00e1pido (Objective-C vs Swift)</p> <p><pre><code>// Objective-C\nNSString *saludo = @\"Hola mundo\";\nNSLog(@\"%@\", saludo);\n</code></pre> <pre><code>// swift\nlet saludo = \"Hola mundo\"\nprint(saludo)\n</code></pre></p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/lenguajes_programacion/#el-relevo-en-android-kotlin-estable-2016-1a-clase-en-2017","title":"El relevo en Android: Kotlin (estable 2016; 1\u00aa clase en 2017)","text":"<p>Kotlin (creado por JetBrains) alcanza su versi\u00f3n 1.0 estable en 2016 y, en 2017, Google lo nombra lenguaje de primera clase para Android. Sus bazas:</p> <ul> <li>Null safety en el sistema de tipos.</li> <li>Sintaxis concisa y expresiva (menos boilerplate que Java).</li> <li>Corutinas para asincron\u00eda y concurrencia m\u00e1s naturales.</li> <li>Interoperabilidad total con Java y opci\u00f3n de compartir c\u00f3digo con Kotlin Multiplatform (Android, iOS, backend, escritorio).</li> </ul> <pre><code>// Java\nString saludo = \"Hola mundo\";\nSystem.out.println(saludo);\n</code></pre> <pre><code>// kotlin\nval saludo = \"Hola mundo\"\nprintln(saludo)\n</code></pre>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/lenguajes_programacion/#hitos-recientes-ui-declarativa-y-multiplataforma","title":"Hitos recientes: UI declarativa y multiplataforma","text":"<p>SwiftUI (Apple) y Jetpack Compose (Android/Kotlin) consolidan el paradigma declarativo: las vistas se derivan del estado, con menos errores y mayor testabilidad.</p> <p>Kotlin Multiplatform permite compartir l\u00f3gica de negocio entre plataformas manteniendo UIs nativas, un equilibrio interesante entre reutilizaci\u00f3n y experiencia nativa.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/lenguajes_programacion/#rankings-y-popularidad-referencias-recientes","title":"Rankings y popularidad (referencias recientes)","text":"<p>Los rankings var\u00edan por metodolog\u00eda (muestra, regiones, qu\u00e9 significa \u201cpopularidad\u201d o \u201cdemanda\u201d). Aun as\u00ed, en los \u00faltimos a\u00f1os Swift y Kotlin aparecen sistem\u00e1ticamente en posiciones destacadas cuando se habla de desarrollo m\u00f3vil nativo.  </p> <p>Para contexto y lectura adicional:</p> <ul> <li>Stack Overflow Developer Survey 2024 (panorama general de lenguajes; utilitario para ver tendencia de uso/agrado): Res</li> <li>JetBrains \u2013 State of Developer Ecosystem 2024 (tendencias por tecnolog\u00edas y ecosistemas, incluye Kotlin/Swift): Res</li> <li>TIOBE Index (popularidad por b\u00fasquedas, hist\u00f3rico a largo plazo; no espec\u00edfico de m\u00f3vil pero \u00fatil como se\u00f1al general): Res</li> <li>GitHub Octoverse (2023/2024) (actividad en repos p\u00fablicos por lenguaje y dominios): Res</li> </ul>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/lenguajes_programacion/#conclusiones","title":"Conclusiones","text":"<p>La programaci\u00f3n m\u00f3vil pas\u00f3 de entornos fragmentados y limitados (Java ME, SDKs propietarios, Symbian C++) a ecosistemas maduros con tooling integrado (iOS/Android).</p> <p>Objective-C y Java establecieron las bases; Swift y Kotlin aportaron seguridad de tipos, concisi\u00f3n y modelos de concurrencia m\u00e1s productivos.</p> <p>El presente (y futuro cercano) se define por:</p> <ul> <li>UI declarativa (SwiftUI/Compose).  </li> <li>Compartici\u00f3n selectiva de c\u00f3digo (Kotlin Multiplatform).  </li> <li>Mejoras constantes de compiladores y tooling.  </li> <li>Apoyo creciente de IA en generaci\u00f3n/refactorizaci\u00f3n de c\u00f3digo.</li> </ul>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/lenguajes_programacion/#notas-de-clase-para-el-curso","title":"Notas de clase (para el curso)","text":"<ul> <li>En Android trabajaremos con Kotlin (corutinas, Flow, Jetpack, Compose).  </li> <li>En iOS trabajaremos con Swift (async/await, Combine, SwiftUI).  </li> <li>El objetivo es practicar patrones modernos (arquitecturas reactivas, capas limpias) y buenas pr\u00e1cticas (testing, inyecci\u00f3n de dependencias, manejo de estado).  </li> </ul> <p>Kotlin</p> <p>Swift</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/sistemas_operativos/","title":"Sistemas Operativos","text":""},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/sistemas_operativos/#introduccion","title":"Introducci\u00f3n","text":"<p>Un sistema operativo m\u00f3vil es el software que gestiona el hardware y los recursos de un dispositivo port\u00e1til (tel\u00e9fonos, tabletas, relojes, etc.), proporcionando servicios b\u00e1sicos y la plataforma sobre la que se ejecutan las aplicaciones. Su evoluci\u00f3n ha estado marcada por los cambios en la tecnolog\u00eda de hardware, en las necesidades de los usuarios y en la competencia entre fabricantes.</p> <p></p> <p>Dispositivos M\u00f3viles</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/sistemas_operativos/#primeros-pasos-sistemas-propietarios-y-basicos-anos-90-inicios-2000","title":"Primeros pasos: sistemas propietarios y b\u00e1sicos (a\u00f1os 90 \u2013 inicios 2000)","text":"<p>En los a\u00f1os 90 los dispositivos m\u00f3viles apenas pod\u00edan ejecutar funciones b\u00e1sicas. Sin embargo, empezaron a aparecer sistemas que, aunque primitivos, sentaron las bases. Antes de que existieran los \u201csmartphones\u201d modernos, los fabricantes desarrollaban sistemas muy simples y cerrados. Ejemplos:</p> <ul> <li>Palm OS (1996): dise\u00f1ado para las PDA (asistentes digitales personales). Permit\u00eda organizar contactos, calendarios y ejecutar apps ligeras.  </li> <li>Windows CE (1996): variante de Microsoft para dispositivos port\u00e1tiles, usado en algunas PDAs y m\u00f3viles tempranos.  </li> <li>Symbian OS (1997): desarrollado inicialmente por Nokia y otros fabricantes. Fue durante a\u00f1os el sistema operativo dominante en m\u00f3viles, especialmente en Europa y Asia.  </li> <li>BlackBerry OS (1999): orientado a correo electr\u00f3nico seguro y teclado f\u00edsico, clave en el sector empresarial.  </li> </ul> <p>Estas plataformas eran muy distintas entre s\u00ed, lo que generaba fragmentaci\u00f3n. Aun as\u00ed, fueron cruciales para experimentar con conceptos como multitarea, aplicaciones externas y sincronizaci\u00f3n con ordenadores.</p> <p>Caracter\u00edsticas comunes: - Interfaces muy limitadas, basadas en men\u00fas sencillos. - Poca memoria y escasa capacidad multitarea. - Ecosistemas de apps reducidos y fragmentados.  </p> <p></p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/sistemas_operativos/#el-salto-a-los-smartphones-20072010","title":"El salto a los smartphones (2007\u20132010)","text":"<p>El 2007 cambi\u00f3 todo: Apple lanz\u00f3 el iPhone con iOS, un sistema dise\u00f1ado desde cero para pantallas t\u00e1ctiles. La experiencia de usuario era radicalmente diferente: fluida, intuitiva, basada en gestos y con un ecosistema controlado de aplicaciones (App Store).</p> <p>En 2008, Google respondi\u00f3 con Android, un sistema basado en Linux y pensado para ser abierto y adaptable a diferentes fabricantes. Esto permiti\u00f3 que marcas como Samsung, HTC o Motorola adoptaran Android y ofrecieran dispositivos muy variados.</p> <p>Durante estos a\u00f1os tambi\u00e9n aparecieron otros actores:</p> <ul> <li>Windows Mobile evolucion\u00f3 hacia Windows Phone, con un dise\u00f1o innovador pero poca tracci\u00f3n.  </li> <li>Symbian y BlackBerry OS intentaron adaptarse, pero empezaron a perder protagonismo.  </li> </ul> <p>Era el inicio de una nueva era en la que las apps, la conectividad y la experiencia t\u00e1ctil se volvieron esenciales.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/sistemas_operativos/#la-era-de-la-consolidacion-20102015","title":"La era de la consolidaci\u00f3n (2010\u20132015)","text":"<ul> <li>iOS segu\u00eda creciendo, con un ecosistema exclusivo y cada vez m\u00e1s pulido.  </li> <li>Android empez\u00f3 a superar en cuota de mercado gracias a su car\u00e1cter abierto y a la variedad de dispositivos.  </li> <li>Windows Phone sorprendi\u00f3 con su interfaz \u201cMetro\u201d, muy diferente a lo visto, pero no consigui\u00f3 atraer a los desarrolladores.  </li> <li>BlackBerry y Symbian se quedaron atr\u00e1s: no lograron adaptarse a la era t\u00e1ctil ni a las nuevas expectativas de los usuarios.</li> </ul> <p>Fue tambi\u00e9n el momento en que las tiendas de aplicaciones se consolidaron como el verdadero motor econ\u00f3mico de los sistemas operativos m\u00f3viles. La famosa frase \u201chay una app para eso\u201d reflejaba el nuevo poder de estos ecosistemas.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/sistemas_operativos/#dominio-absoluto-de-ios-y-android-2015actualidad","title":"Dominio absoluto de iOS y Android (2015\u2013actualidad)","text":"<p>A partir de 2015, el mercado se consolid\u00f3 en un duopolio:</p> <ul> <li> <p>Android: sistema abierto, utilizado por decenas de fabricantes (Samsung, Xiaomi, Huawei, etc.), con gran diversidad de dispositivos y gamas.  Android</p> </li> <li> <p>IOS: sistema cerrado, exclusivo de Apple, con gran integraci\u00f3n entre hardware y software y un ecosistema muy rentable.  IOS</p> </li> </ul> <p>Caracter\u00edsticas de esta etapa:</p> <ul> <li>Interfaces limpias y fluidas, centradas en gestos y accesibilidad.  </li> <li>Mejoras constantes en seguridad, actualizaciones peri\u00f3dicas y control de permisos.  </li> <li>Ecosistemas ampliados: relojes inteligentes, tablets, televisores, autom\u00f3viles.  </li> <li>Introducci\u00f3n de inteligencia artificial en asistentes como Siri y Google Assistant.  </li> </ul> <p>Otros sistemas como Tizen, KaiOS o HarmonyOS han intentado encontrar un hueco, pero su alcance ha sido limitado en comparaci\u00f3n.</p> <p></p> <p>Timeline Android</p> <p></p> <p>Timeline IOS</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/sistemas_operativos/#conclusiones","title":"Conclusiones","text":"<ul> <li>La evoluci\u00f3n de los sistemas operativos m\u00f3viles refleja el paso de dispositivos simples y cerrados a plataformas avanzadas y globales.  </li> <li>Palm, Symbian y BlackBerry fueron pioneros, pero quedaron atr\u00e1s frente a la revoluci\u00f3n t\u00e1ctil y de apps iniciada por iOS y Android.  </li> <li>Hoy, estos dos sistemas no solo dominan los tel\u00e9fonos, sino que son la base de ecosistemas completos que abarcan relojes inteligentes, tabletas, televisores y m\u00e1s.  </li> <li>El futuro apunta a una mayor integraci\u00f3n con inteligencia artificial, m\u00e1s seguridad y privacidad, y un crecimiento de la convergencia entre dispositivos.  </li> </ul>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/swift/","title":"Swift","text":""},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/swift/#swift-el-lenguaje-nativo-de-ios","title":"Swift: el lenguaje nativo de iOS","text":""},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/swift/#introduccion","title":"Introducci\u00f3n","text":"<p>Swift es el lenguaje moderno desarrollado por Apple para crear aplicaciones en sus plataformas: iOS, iPadOS, macOS, watchOS y tvOS. Naci\u00f3 para sustituir a Objective-C, ofreciendo una sintaxis m\u00e1s sencilla, mayor seguridad y mejor rendimiento, lo que lo ha convertido en el est\u00e1ndar de facto para el desarrollo en el ecosistema Apple.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/swift/#historia","title":"Historia","text":"<p>Swift fue presentado en la WWDC 2014 como una alternativa fresca y poderosa a Objective-C. Su dise\u00f1o estuvo influenciado por lenguajes como Python, Ruby y Rust, buscando combinar facilidad de uso con eficiencia. En 2015, Apple dio un paso decisivo: lo convirti\u00f3 en open source, lo que permiti\u00f3 que la comunidad contribuyera a su evoluci\u00f3n. Hoy Swift est\u00e1 en constante desarrollo bajo la Swift.org Foundation, consolid\u00e1ndose como uno de los lenguajes m\u00e1s valorados por los desarrolladores.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/swift/#caracteristicas-principales","title":"Caracter\u00edsticas principales","text":"<ul> <li>Sintaxis clara y moderna, que favorece la legibilidad y productividad.  </li> <li>Gesti\u00f3n segura de memoria mediante Automatic Reference Counting (ARC).  </li> <li>Alto rendimiento, comparable e incluso superior a C++ en algunas operaciones.  </li> <li>Orientado a la seguridad, con control estricto de tipos y prevenci\u00f3n de null por defecto.  </li> <li>Playgrounds en Xcode, que permiten experimentar en tiempo real con c\u00f3digo interactivo.  </li> <li>Interoperabilidad con Objective-C, facilitando la migraci\u00f3n de proyectos antiguos.  </li> <li>Enfoque multiplataforma, ya que tambi\u00e9n puede usarse en servidores (con frameworks como Vapor) y en proyectos open source fuera del ecosistema Apple.</li> </ul>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/swift/#ventajas","title":"Ventajas","text":"<ul> <li>Experiencia de desarrollo muy productiva dentro del ecosistema Apple.  </li> <li>Lenguaje moderno y en continua evoluci\u00f3n, con fuerte respaldo de Apple.  </li> <li>C\u00f3digo m\u00e1s seguro y menos propenso a errores que Objective-C.  </li> <li>Excelente rendimiento, optimizado para hardware y sistemas de Apple.  </li> </ul>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/swift/#desventajas","title":"Desventajas","text":"<ul> <li>Ecosistema cerrado: Swift se usa casi exclusivamente en productos Apple.  </li> <li>Cambios frecuentes en versiones tempranas, que en su d\u00eda afectaron la estabilidad de proyectos.  </li> <li>Curva de aprendizaje para quienes vengan de lenguajes distintos a C/Java puede ser m\u00e1s pronunciada.  </li> <li>Dependencia fuerte de las herramientas oficiales (Xcode), con poca flexibilidad en entornos externos.  </li> </ul> <p>Documentaci\u00f3n</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/x_code/","title":"Xcode","text":""},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/x_code/#introduccion","title":"Introducci\u00f3n","text":"<p>Xcode es el IDE oficial de Apple para el desarrollo en sus plataformas: iOS, macOS, watchOS y tvOS. Es la herramienta imprescindible para programar en Swift y Objective-C, con la que se pueden crear, depurar y desplegar aplicaciones directamente en dispositivos Apple o en simuladores.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/x_code/#caracteristicas-principales","title":"Caracter\u00edsticas principales","text":"<ul> <li>Editor de c\u00f3digo con autocompletado y refactorizaci\u00f3n.  </li> <li>Interfaz visual para dise\u00f1ar pantallas con Storyboard o SwiftUI.  </li> <li>Simuladores de todos los dispositivos Apple.  </li> <li>Integraci\u00f3n con Git y con la App Store para distribuci\u00f3n.  </li> <li>Soporte de pruebas unitarias y de interfaz.  </li> <li>Herramientas de profiling (Instruments) para rendimiento, memoria y energ\u00eda.  </li> </ul>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/x_code/#estructura-de-un-proyecto-en-xcode","title":"Estructura de un proyecto en Xcode","text":"<p>Un proyecto en Xcode genera varias carpetas y archivos clave:</p> <ul> <li> <p>NombreProyecto.xcodeproj   Archivo principal del proyecto. Contiene la configuraci\u00f3n y debe abrirse con Xcode.  </p> </li> <li> <p>AppDelegate.swift   Archivo de entrada que gestiona el ciclo de vida de la aplicaci\u00f3n.  </p> </li> <li> <p>SceneDelegate.swift (en proyectos modernos con SwiftUI o m\u00faltiples escenas)   Controla las distintas escenas o ventanas de la app.  </p> </li> <li> <p>ViewController.swift   Controladores de vista que gestionan la l\u00f3gica de cada pantalla.  </p> </li> <li> <p>Main.storyboard (o ContentView.swift en SwiftUI)   Define la interfaz gr\u00e1fica, ya sea de forma visual (Storyboard) o declarativa (SwiftUI).  </p> </li> <li> <p>Assets.xcassets   Carpeta que contiene los recursos gr\u00e1ficos: iconos, im\u00e1genes, colores, etc.  </p> </li> <li> <p>Info.plist   Archivo de configuraci\u00f3n con informaci\u00f3n clave: nombre de la app, permisos de acceso (c\u00e1mara, red, ubicaci\u00f3n), entre otros.  </p> </li> <li> <p>Tests/   Carpeta con pruebas unitarias.  </p> </li> <li> <p>UITests/   Carpeta con pruebas de interfaz.  </p> </li> </ul> <p>Esta organizaci\u00f3n permite separar de forma clara la l\u00f3gica, la interfaz, los recursos y la configuraci\u00f3n de la app.</p>"},{"location":"Bloque3_Programacion_Despliegue/despliegue_apps/","title":"Despliegue de Apps","text":"<p>Contenido en construcci\u00f3n...</p>"},{"location":"Bloque3_Programacion_Despliegue/errores_logging/","title":"Gesti\u00f3n de errores y Logging","text":"<p>Contenido en construcci\u00f3n...</p>"},{"location":"Bloque3_Programacion_Despliegue/sensores_integracion_datos/","title":"Sensores e Integracion de Datos","text":"<p>Contenido en construcci\u00f3n...</p>"}]}