{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Programaci\u00f3n de Aplicaciones M\u00f3viles NativasBienvenido a PAMN","text":""},{"location":"#programacion-de-aplicaciones-moviles-nativas_1","title":"\ud83d\udcf1 Programaci\u00f3n de Aplicaciones M\u00f3viles Nativas","text":"<p>Programaci\u00f3n de Aplicaciones M\u00f3viles Nativas (PAMN) es una asignatura optativa de 4.\u00ba curso del Grado en Ingenier\u00eda Inform\u00e1tica. Su objetivo es capacitar al alumnado en el dise\u00f1o, desarrollo y despliegue de aplicaciones m\u00f3viles nativas para sistemas operativos actuales. Se abordan aspectos como accesibilidad, calidad del software y pr\u00e1cticas DevOps. Esta materia ampl\u00eda los conocimientos adquiridos previamente en programaci\u00f3n m\u00f3vil, y refuerza un perfil profesional muy demandado en el sector tecnol\u00f3gico actual.</p> <p> </p> <p> </p> <p> </p>"},{"location":"contenidos/","title":"Contenidos","text":"<p>Programaci\u00f3n de Aplicaciones M\u00f3viles Nativas (PAMN) Los bloques est\u00e1n estructurados con una secuencia acad\u00e9mica temporal, pero sus contenidos est\u00e1n estrechamente interrelacionados. Esta integraci\u00f3n favorece un aprendizaje progresivo y coherente, orientado a la realizaci\u00f3n del trabajo final de la asignatura con una visi\u00f3n global y aplicada del desarrollo de apps m\u00f3viles.</p> <p>BLOQUE 1. Ingenier\u00eda de Desarrollo de Aplicaciones M\u00f3viles Nativas Aborda los fundamentos de la ingenier\u00eda de aplicaciones m\u00f3viles, incluyendo el ciclo de vida del desarrollo, principios de arquitectura, accesibilidad y dise\u00f1o de interfaces. Proporciona una base s\u00f3lida para crear aplicaciones centradas en el usuario, accesibles y alineadas con est\u00e1ndares de calidad y normativas actuales.</p> <p>BLOQUE 2. Desarrollo de Aplicaciones M\u00f3viles Nativas profundiza en tecnolog\u00edas clave del desarrollo m\u00f3vil, como sistemas operativos, lenguajes de programaci\u00f3n, frameworks y bases de datos. Tambi\u00e9n introduce principios de calidad del software y patrones de dise\u00f1o, esenciales para crear aplicaciones eficientes, escalables y mantenibles en un entorno de desarrollo profesional.</p> <p>BLOQUE 3. Programaci\u00f3n y Despliegue de Aplicaciones M\u00f3viles Nativas exploran aspectos avanzados de programaci\u00f3n m\u00f3vil como la integraci\u00f3n de sensores, el manejo de errores y el logging. Se trabaja adem\u00e1s el despliegue de aplicaciones y su integraci\u00f3n en el ciclo DevOps, preparando al estudiante para llevar apps m\u00f3viles desde el desarrollo hasta la producci\u00f3n.</p>"},{"location":"Bloque1_Ingenieria_Apps/accesibilidad_normativa/","title":"Accesibilidad y Normativa","text":"<p>Contenido en construcci\u00f3n...</p>"},{"location":"Bloque1_Ingenieria_Apps/diseno_interfaces/","title":"Diseno de Interfaces","text":"<p>Contenido en construcci\u00f3n...</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/","title":"Ciclo de Vida y Arquitectura de Aplicaciones M\u00f3viles","text":"<p>Selecciona un subtema del men\u00fa lateral.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/arquitectura/","title":"Arquitectura de Aplicaciones M\u00f3viles","text":"<p>La arquitectura de una aplicaci\u00f3n m\u00f3vil define la organizaci\u00f3n interna de sus componentes y c\u00f3mo se comunican entre s\u00ed. Constituye el esqueleto que sostiene el desarrollo y mantenimiento de la app, asegurando escalabilidad, calidad y facilidad de evoluci\u00f3n. En el contexto de PAMN, comprender la arquitectura es fundamental para formar profesionales capaces de crear aplicaciones robustas y alineadas con las buenas pr\u00e1cticas de la industria.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/arquitectura/#objetivos-de-la-arquitectura","title":"Objetivos de la arquitectura","text":"<ul> <li>Proporcionar un marco estructurado para el desarrollo.  </li> <li>Asegurar la separaci\u00f3n de responsabilidades.  </li> <li>Facilitar la escalabilidad y la mantenibilidad.  </li> <li>Simplificar la integraci\u00f3n de nuevas funcionalidades.  </li> <li>Reforzar la seguridad y el control del proyecto.  </li> </ul>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/arquitectura/#por-que-es-importante","title":"\u00bfPor qu\u00e9 es importante?","text":"<p>Una buena arquitectura:</p> <ul> <li>Estructura: Una arquitectura s\u00f3lida proporciona un esqueleto robusto para el Proyecto, asegurando que cada componente encaje de manera coherente y eficiente. </li> </ul> <p></p> <ul> <li>Planificaci\u00f3n: Facilita la toma de decisiones anticipadas, permitiendo evitar posibles obst\u00e1culos y puntos cr\u00edticos en el desarrollo. </li> </ul> <p></p> <ul> <li>Control: Con una arquitectura bien definida, es  m\u00e1s sencillo monitorizar el progreso, identificar desviaciones  y garantizar que el Proyecto se mantenga en el camino correcto.</li> </ul> <p> </p> <ul> <li>Optimizaci\u00f3n del proceso: Una  buena arquitectura simplifica la integraci\u00f3n de nuevas caracter\u00edsticas y facilita las actualizaciones, asegurando la escalabilidad y adaptabilidad del Proyecto a largo plazo. </li> </ul> <p> </p> <ul> <li>Separaci\u00f3n de capas: Consiste en dividir un sistema en capas o m\u00f3dulos independientes, cada uno con una responsabilidad espec\u00edfica. Podemos distinguir entre presentaci\u00f3n, l\u00f3gica de negocio y gesti\u00f3n de datos.</li> </ul> <p> </p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/arquitectura/#modelos-de-arquitectura-mas-utilizados","title":"Modelos de arquitectura m\u00e1s utilizados","text":""},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/arquitectura/#1-mvc-modelovistacontrolador","title":"1. MVC (Modelo\u2013Vista\u2013Controlador)","text":"<p>Separa la app en tres componentes principales: modelo, vista y controlador. </p> <ul> <li>Modelo: Datos y l\u00f3gica de negocio.  </li> <li>Vista: Interfaz gr\u00e1fica.  </li> <li>Controlador: Act\u00faa como intermediario, manejando la entrada del usuario y actualizando tanto la vista como el modelo.  </li> </ul> <p>Ventajas: La separaci\u00f3n clara entre la l\u00f3gica de la interfaz de usuario y la l\u00f3gica de negocio. Inconvenientes: El controlador tiende a sobrecargarse en proyectos grandes. La vista y el controlador suelen estar m\u00e1s acoplados en en otras arquitecturas. </p> <p></p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/arquitectura/#2-mvp-modelovistapresentador","title":"2. MVP (Modelo\u2013Vista\u2013Presentador)","text":"<p>Separa la l\u00f3gica de presentaci\u00f3n de la l\u00f3gica de negocio.</p> <ul> <li>Modelo: Mantiene datos y reglas de negocio.  </li> <li>Vista: Muestra informaci\u00f3n, delega l\u00f3gica.  </li> <li>Presentador: Gestiona la l\u00f3gica de negocio y actualiza la vista.  </li> </ul> <p>Ventajas: La separaci\u00f3n clara entre la l\u00f3gica de la interfaz de usuario y la l\u00f3gica de negocio. Facilita una alta testabilidad. Inconvenientes: Puede generar c\u00f3digo m\u00e1s complejo.  </p> <p></p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/arquitectura/#3-mvvm-modelovistavistamodelo","title":"3. MVVM (Modelo\u2013Vista\u2013VistaModelo)","text":"<p>Arquitectura que utiliza un modelo de vista para gestionar la l\u00f3gica de la aplicaci\u00f3n.</p> <ul> <li>Modelo: Gestiona datos y l\u00f3gica de negocio.  </li> <li>Vista: Muestra la interfaz y se comunica con la vista modelo.  </li> <li>VistaModelo: Maneja la l\u00f3gica de presentaci\u00f3n y comunica vista y modelo.  </li> </ul> <p>Ventajas: menor acoplamiento y compatible con programaci\u00f3n reactiva.  </p> <p></p> <p>Modelo\u2013Vista\u2013VistaModelo (MVVM).</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/arquitectura/#4-mvi-modelovistaintencion","title":"4. MVI (Modelo\u2013Vista\u2013Intenci\u00f3n)","text":"<p>Se centra en la intenci\u00f3n del usuario y utiliza un flujo de datos unidireccional.</p> <ul> <li>Modelo: Datos y l\u00f3gica de negocio.  </li> <li>Vista: Muestra el estado actual de la aplicaci\u00f3n.  </li> <li>Intenciones: Representa las intenciones o acciones del usuario.   </li> </ul> <p>Ventaja principal: Enfoque c\u00edclico y reactivo que maneja el flujo de datos y eventos.  </p> <p></p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/arquitectura/#5-arquitectura-hexagonal","title":"5. Arquitectura Hexagonal","text":"<p>Divide la app en capas:</p> <ul> <li>N\u00facleo: Dominio que representa la l\u00f3gica de negocio.  </li> <li>Aplicaci\u00f3n: Maneja los casos de uso.  </li> <li>Infraestructura: Maneja los adaptadores de infraestructura, incluyendo los controladores (adaptadores que manejan la interfaz de usuario).  </li> </ul> <p>Los adaptadores se conectan a los puertos. El diagrama sigue el principio de desacoplamiento de la arquitectura hexagonal. La l\u00f3gica de negocio est\u00e1 completamente aislada de los detalles de implementaci\u00f3n externa (infraestructura, tecnolog\u00edas). Las interacciones entre la aplicaci\u00f3n y el mundo exterior se realizan a trav\u00e9s de puertos y adaptadores, lo que garantiza que el n\u00facleo del sistema sea independiente de la infraestructura. Este patr\u00f3n facilita el cambio de tecnolog\u00edas externas sin modificar el n\u00facleo, promueve la testabilidad y permite que cada componente sea mantenido y desarrollado de manera independiente.</p> <p></p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/arquitectura/#factores-para-elegir-la-arquitectura-consideraciones-clave","title":"Factores para elegir la arquitectura. Consideraciones clave.","text":"<ul> <li>Requerimientos: Entender las necesidades espec\u00edficas y objetivos del proyecto para determinar qu\u00e9 arquitectura se alinea mejor.</li> <li>Rendimiento: Evaluar c\u00f3mo cada arquitectura puede influir en la velocidad, respuesta y eficiencia del sistema.</li> <li>Integraci\u00f3n con otros Sistemas: Si el proyecto necesita interactuar con otros sistemas o aplicaciones, la arquitectura debe facilitar estas integraciones.</li> <li>Recursos: Evaluar la inversi\u00f3n necesaria en t\u00e9rminos de tiempo, dinero y recursos humanos para implementar y mantener</li> <li>Seguridad: Garantizar que la arquitectura elegida ofrezca las medidas de seguridad adecuadas para proteger datos y procesos.</li> <li>Facilidad de mantenimiento: La facilidad con la que se pueden hacer cambios, correcciones o mejoras en el sistema a lo largo del tiempo.</li> </ul>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/arquitectura/#estructurando-aplicaciones","title":"Estructurando aplicaciones.","text":""},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/arquitectura/#relacion-con-devops","title":"Relaci\u00f3n con DevOps","text":"<p>La arquitectura m\u00f3vil est\u00e1 alineada con la filosof\u00eda DevOps, ya que:  </p> <ul> <li>Favorece la automatizaci\u00f3n de pruebas e integraci\u00f3n continua.  </li> <li>Permite despliegues m\u00e1s r\u00e1pidos y seguros.  </li> <li>Mejora la observabilidad en producci\u00f3n.  </li> <li>Facilita la escalabilidad de las aplicaciones.  </li> </ul>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/arquitectura/#conclusiones","title":"Conclusiones","text":"<ul> <li>La arquitectura es el pilar central de una app m\u00f3vil.  </li> <li>Existen m\u00faltiples patrones (MVC, MVP, MVVM, MVI, Hexagonal), cada uno con pros y contras.  </li> <li>La elecci\u00f3n depende de los objetivos, recursos y contexto del proyecto.  </li> <li>Una arquitectura alineada con DevOps asegura calidad y entrega continua.  </li> </ul>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/ciclo_vida_devops/","title":"Ciclo de vida de una aplicaci\u00f3n m\u00f3vil y su relaci\u00f3n con DevOps","text":"<p>El ciclo de vida de una aplicaci\u00f3n m\u00f3vil describe todas las fases que atraviesa una app desde su concepci\u00f3n hasta su retirada. Comprender este ciclo permite desarrollar soluciones m\u00e1s robustas, escalables y mantenibles, optimizando recursos y minimizando errores. En el contexto de PAMN, este enfoque es esencial para preparar al estudiante en entornos reales de desarrollo.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/ciclo_vida_devops/#objetivos-del-ciclo-de-vida","title":"Objetivos del ciclo de vida","text":"<ul> <li>Establecer un marco ordenado para el desarrollo.</li> <li>Identificar y controlar riesgos desde fases tempranas.</li> <li>Asegurar la calidad del producto desde su dise\u00f1o.</li> <li>Permitir una entrega continua y sostenible.</li> </ul>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/ciclo_vida_devops/#breve-historia","title":"Breve historia","text":"<p>Inicialmente, el ciclo de vida del software segu\u00eda modelos r\u00edgidos como el modelo en cascada, donde cada fase deb\u00eda completarse antes de pasar a la siguiente. Con la evoluci\u00f3n de las metodolog\u00edas \u00e1giles, se impuso una visi\u00f3n iterativa e incremental del desarrollo, y con la llegada del desarrollo m\u00f3vil surgieron nuevas necesidades: integraci\u00f3n continua, automatizaci\u00f3n, despliegue frecuente y monitorizaci\u00f3n en tiempo real. Es aqu\u00ed donde emerge DevOps, una pr\u00e1ctica que unifica el desarrollo (Dev) y las operaciones (Ops).</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/ciclo_vida_devops/#devops-como-interseccion-de-disciplinas","title":"DevOps como intersecci\u00f3n de disciplinas","text":"<p>La imagen anterior representa la integraci\u00f3n de tres dimensiones fundamentales: desarrollo, operaciones y control de calidad. El \u00e1rea donde se superponen da lugar al enfoque DevOps, que busca romper los silos tradicionales, fomentar la colaboraci\u00f3n entre equipos y automatizar todo lo posible para entregar valor de forma continua al usuario final.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/ciclo_vida_devops/#el-ciclo-devops-en-accion","title":"El ciclo DevOps en acci\u00f3n","text":"<p>Este diagrama muestra el flujo t\u00edpico de un proceso DevOps, en forma de bucle infinito. Cada etapa est\u00e1 conectada a la siguiente, favoreciendo una entrega continua e integraci\u00f3n constante. Las fases principales son:</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/ciclo_vida_devops/#1-planificacion","title":"1. Planificaci\u00f3n","text":"<p>Definici\u00f3n de requisitos, tareas y objetivos. Se pueden utilizar herramientas como Jira, Trello o Azure Boards.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/ciclo_vida_devops/#2-codificacion","title":"2. Codificaci\u00f3n","text":"<p>Desarrollo de funcionalidades. Aqu\u00ed se emplean lenguajes como Kotlin, Swift, Dart, Java o frameworks como React Native. Herramientas: Android Studio, Xcode, VS Code.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/ciclo_vida_devops/#3-compilacion","title":"3. Compilaci\u00f3n","text":"<p>Generaci\u00f3n de artefactos ejecutables. Herramientas comunes: Gradle, Maven, Xcode Build.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/ciclo_vida_devops/#4-pruebas","title":"4. Pruebas","text":"<p>Ejecutadas de forma automatizada o manual. Destacan frameworks como JUnit, Espresso, XCTest, o pruebas E2E con Appium.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/ciclo_vida_devops/#5-publicacion","title":"5. Publicaci\u00f3n","text":"<p>Subida a tiendas como Google Play o App Store. Automatizable con Fastlane, GitHub Actions, Bitrise.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/ciclo_vida_devops/#6-despliegue","title":"6. Despliegue","text":"<p>Distribuci\u00f3n en entornos de producci\u00f3n o pruebas (alpha, beta). Puede hacerse v\u00eda Firebase App Distribution o TestFlight.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/ciclo_vida_devops/#7-monitorizacion","title":"7. Monitorizaci\u00f3n","text":"<p>An\u00e1lisis del rendimiento y errores. Herramientas t\u00edpicas: Firebase Crashlytics, Sentry, New Relic.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/ciclo_vida_devops/#8-operaciones","title":"8. Operaciones","text":"<p>Gesti\u00f3n de la infraestructura, soporte y mantenimiento. Se apoyan en CI/CD (GitHub Actions, GitLab CI, Jenkins) e infraestructura como c\u00f3digo (IaC).</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/mvvm/","title":"Modelo\u2013Vista\u2013VistaModelo (MVVM)","text":""},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/mvvm/#1-crear-el-modelo-model","title":"1. Crear el modelo (Model)","text":"<p>El modelo representa la capa de datos de la aplicaci\u00f3n. Esta capa se encarga de manejar la l\u00f3gica de negocio, interactuar con bases de datos o servicios externos y proporcionar los datos que necesita la interfaz de usuario.</p> <pre><code>\n// Model.kt\ndata class User(val id: Int, val name: String, val age: Int)\n\n// Puede ser una clase de repositorio que maneja la obtenci\u00f3n de datos\nclass UserRepository {\n\n    private val userList = listOf(\n        User(1, \"John Doe\", 30),\n        User(2, \"Jane Smith\", 25)\n    )\n\n    // Simulamos la obtenci\u00f3n de los datos\n    fun getUsers(): List&lt;User&gt; = userList\n}\n\n</code></pre>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/mvvm/#2-crear-la-vista-modelo-viewmodel","title":"2. Crear la vista modelo (ViewModel)","text":"<p>La VistaModelo es el intermediario entre el Modelo y la Vista. Proporciona los datos de forma que la vista pueda observar los cambios y actualizarse autom\u00e1ticamente cuando los datos cambien. Utilizamos LiveData para hacer la comunicaci\u00f3n entre el ViewModel y la Vista, de forma que la Vista observe los cambios y reaccione autom\u00e1ticamente.</p> <pre><code>\n// UserViewModel.kt\nimport androidx.lifecycle.LiveData\nimport androidx.lifecycle.MutableLiveData\nimport androidx.lifecycle.ViewModel\n\nclass UserViewModel : ViewModel() {\n\n    private val userRepository = UserRepository()\n\n    // MutableLiveData que puede ser observada por la vista\n    private val _users = MutableLiveData&lt;List&lt;User&gt;&gt;()\n\n    // Exponemos los datos como LiveData, para que la vista observe los cambios\n    val users: LiveData&lt;List&lt;User&gt;&gt;\n        get() = _users\n\n    // Cargar los usuarios y actualizar el LiveData\n    fun loadUsers() {\n        val usersFromRepo = userRepository.getUsers()\n        _users.value = usersFromRepo\n    }\n}\n\n</code></pre>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/mvvm/#2-crear-la-vista-view","title":"2. Crear la vista (View)","text":"<p>La Vista en Android puede ser una Activity, un Fragment o cualquier componente de la interfaz que observe el ViewModel. En este caso, usaremos una Activity que observar\u00e1 los cambios del ViewModel y reaccionar\u00e1 en consecuencia. Aqu\u00ed es donde entrar\u00eda el uso de DataBinding para hacer el enlace de datos entre el ViewModel y la Vista.</p>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/mvvm/#1-habilitamos-databinding-en-el-archivo-buildgradle","title":"1. Habilitamos Databinding en el archivo build.gradle:","text":"<pre><code>\nandroid {\n    ...\n    buildFeatures {\n        dataBinding true\n    }\n}\n\n</code></pre>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/mvvm/#2-creamos-el-layout-xml-con-el-enlace-de-datos-al-viewmodel","title":"2. Creamos el layout XML con el enlace de datos al ViewModel:","text":"<pre><code>\n&lt;!-- activity_main.xml --&gt;\n&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt;\n\n    &lt;data&gt;\n        &lt;!-- Vinculamos el ViewModel --&gt;\n        &lt;variable\n            name=\"viewModel\"\n            type=\"com.example.mvvmexample.UserViewModel\" /&gt;\n    &lt;/data&gt;\n\n    &lt;LinearLayout\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\"&gt;\n\n        &lt;TextView\n            android:id=\"@+id/userText\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:text=\"Users\" /&gt;\n\n        &lt;ListView\n            android:id=\"@+id/userListView\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\" /&gt;\n    &lt;/LinearLayout&gt;\n&lt;/layout&gt;\n\n</code></pre>"},{"location":"Bloque1_Ingenieria_Apps/ciclo_vida_arquitectura/mvvm/#3-implementamos-la-activity-que-observara-el-viewmodel","title":"3. Implementamos la activity que observar\u00e1 el ViewModel:","text":"<pre><code>\n// MainActivity.kt\nimport android.os.Bundle\nimport androidx.activity.viewModels\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.databinding.DataBindingUtil\nimport androidx.lifecycle.Observer\nimport com.example.mvvmexample.databinding.ActivityMainBinding\n\nclass MainActivity : AppCompatActivity() {\n\n    // Instanciamos el ViewModel usando la funci\u00f3n por defecto\n    private val userViewModel: UserViewModel by viewModels()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        // Enlazamos el layout con DataBinding\n        val binding: ActivityMainBinding =\n            DataBindingUtil.setContentView(this, R.layout.activity_main)\n\n        // Asignamos el ViewModel a la vista\n        binding.viewModel = userViewModel\n        binding.lifecycleOwner = this // Para que el binding observe los cambios\n\n        // Observamos el LiveData del ViewModel\n        userViewModel.users.observe(this, Observer { users -&gt;\n            // Actualizamos la interfaz cuando los datos cambian\n            binding.userText.text = users.joinToString { it.name }\n        })\n\n        // Cargar los datos en el ViewModel\n        userViewModel.loadUsers()\n    }\n}\n\n\n</code></pre>"},{"location":"Bloque2_Desarrollo_Apps/bases_datos/","title":"Bases de Datos","text":"<p>Contenido en construcci\u00f3n...</p>"},{"location":"Bloque2_Desarrollo_Apps/calidad_software/","title":"Calidad del Software","text":"<p>Contenido en construcci\u00f3n...</p>"},{"location":"Bloque2_Desarrollo_Apps/patrones_diseno/","title":"Patrones de Dise\u00f1o","text":"<p>Selecciona un subtema del men\u00fa lateral.</p>"},{"location":"Bloque2_Desarrollo_Apps/patrones_diseno/comportamiento/","title":"Patrones de comportamiento","text":"<p>Contenido en construcci\u00f3n...</p>"},{"location":"Bloque2_Desarrollo_Apps/patrones_diseno/principios_estructurales/","title":"Principios y patrones estructurales cl\u00e1sicos","text":"<p>Contenido en construcci\u00f3n...</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/","title":"Sistemas Operativos para Dispositivos M\u00f3viles","text":"<p>Selecciona un subtema del men\u00fa lateral.</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/frameworks_desarrollo/","title":"Frameworks de Desarrollo","text":"<p>Contenido en construcci\u00f3n...</p>"},{"location":"Bloque2_Desarrollo_Apps/sistemas_operativos/lenguajes_programacion/","title":"Lenguajes de Programaci\u00f3n","text":"<p>Contenido en construcci\u00f3n...</p>"},{"location":"Bloque3_Programacion_Despliegue/despliegue_apps/","title":"Despliegue de Apps","text":"<p>Contenido en construcci\u00f3n...</p>"},{"location":"Bloque3_Programacion_Despliegue/errores_logging/","title":"Gesti\u00f3n de errores y Logging","text":"<p>Contenido en construcci\u00f3n...</p>"},{"location":"Bloque3_Programacion_Despliegue/sensores_integracion_datos/","title":"Sensores e Integracion de Datos","text":"<p>Contenido en construcci\u00f3n...</p>"}]}